/* App.css - complete stylesheet for FlightOps Chat UI */

/* Reset and base styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  height: 100vh;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app-container {
  display: flex;
  height: 100vh;
}

/* Sidebar Styles */
.sidebar {
  width: 280px;
  background: linear-gradient(180deg, #1e1b4b 0%, #312e81 100%);
  color: white;
  display: flex;
  flex-direction: column;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.12);
}

.sidebar-header {
  padding: 2rem 1.5rem 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.logo-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.logo-placeholder {
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, #818cf8, #4f46e5);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  margin-bottom: 1rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
}

.sidebar-header h1 {
  font-size: 1.1rem;
  font-weight: 600;
  color: #e0e7ff;
}

.sidebar-content {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
}

.sidebar-section {
  margin-bottom: 2rem;
}

.sidebar-section h3 {
  font-size: 0.9rem;
  font-weight: 600;
  color: #a5b4fc;
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sidebar-btn {
  width: 100%;
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  color: white;
  cursor: pointer;
  transition: all 0.22s ease;
  text-align: left;
  font-size: 0.9rem;
}

.sidebar-btn:hover {
  background: rgba(255, 255, 255, 0.14);
  transform: translateX(4px);
}

.recent-query {
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.04);
  border-radius: 6px;
  font-size: 0.85rem;
  color: #c7d2fe;
  border-left: 3px solid #818cf8;
}

/* Indigo GIF Placeholder */
.indigo-gif-placeholder {
  margin-top: auto;
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.04);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.gif-container {
  text-align: center;
}

.animated-plane {
  font-size: 3rem;
  margin-bottom: 1rem;
  animation: float 3s ease-in-out infinite;
}

@keyframes float {
  0%, 100% { 
    transform: translateY(0px); 
  }
  50% { 
    transform: translateY(-10px); 
  }
}

.gif-container p {
  color: #a5b4fc;
  font-size: 0.9rem;
  margin-bottom: 0.25rem;
}

/* Main Content */
.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #f8fafc;
  overflow: hidden;
}

.header {
  background: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  padding: 1rem 0;
  display: flex;
  align-items: center;
  justify-content: center;
}

.header-content {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.header img {
  height: 40px;
}

.header h1 {
  font-size: 1.5rem;
  font-weight: 700;
  color: #4f46e5;
}

/* Scrollbar Styling */
.sidebar-content::-webkit-scrollbar {
  width: 6px;
}

.sidebar-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.02);
}

.sidebar-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.15);
  border-radius: 8px;
}

.sidebar-content::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.25);
}

/* Chat Container */
.chat-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: white;
  margin: 1rem;
  border-radius: 16px;
  box-shadow: 0 8px 30px rgba(2, 6, 23, 0.06);
  overflow: hidden;
}

.messages-container {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
  background: #f8fafc;
}

/* Message Bubbles */
.message {
  margin-bottom: 1.5rem;
  display: flex;
  animation: slideIn 0.3s ease-out;
}

.user-message {
  justify-content: flex-end;
}

.assistant-message {
  justify-content: flex-start;
}

.message-content {
  max-width: 70%;
  padding: 1rem 1.25rem;
  border-radius: 18px;
  position: relative;
  word-wrap: break-word;
}

.user-message .message-content {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border-bottom-right-radius: 6px;
}

.assistant-message .message-content {
  background: white;
  color: #374151;
  border: 1px solid #e5e7eb;
  border-bottom-left-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

.message-text {
  line-height: 1.5;
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
}

.message-timestamp {
  font-size: 0.75rem;
  opacity: 0.7;
  margin-top: 0.5rem;
}

.user-message .message-timestamp {
  text-align: right;
  color: rgba(255, 255, 255, 0.8);
}

.assistant-message .message-timestamp {
  text-align: left;
  color: #6b7280;
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Loading Animation */
.loading-message {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin-bottom: 1.5rem;
}

.loading-dots {
  display: flex;
  gap: 0.25rem;
  padding: 1rem 1.25rem;
  background: white;
  border-radius: 18px;
  border: 1px solid #e5e7eb;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #9ca3af;
  animation: bounce 1.4s infinite ease-in-out;
}

.loading-dots span:nth-child(1) { 
  animation-delay: -0.32s; 
}
.loading-dots span:nth-child(2) { 
  animation-delay: -0.16s; 
}

@keyframes bounce {
  0%, 80%, 100% { 
    transform: scale(0.8); 
    opacity: 0.5; 
  }
  40% { 
    transform: scale(1); 
    opacity: 1; 
  }
}

.loading-timestamp {
  font-size: 0.75rem;
  color: #6b7280;
  margin-top: 0.5rem;
  margin-left: 1.25rem;
}

/* Input Container */
.input-container {
  display: flex;
  gap: 0.75rem;
  padding: 1.5rem;
  background: white;
  border-top: 1px solid #e5e7eb;
}

.message-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 1px solid #d1d5db;
  border-radius: 12px;
  font-size: 0.95rem;
  outline: none;
  transition: all 0.2s;
  background: white;
}

.message-input:focus {
  border-color: #4f46e5;
  box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.message-input:disabled {
  background-color: #f9fafb;
  cursor: not-allowed;
}

.send-button {
  padding: 0.75rem 1.5rem;
  background: linear-gradient(135deg, #4f46e5, #7c3aed);
  color: white;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.send-button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
}

.send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

/* Status Indicator */
.status-indicator {
  padding: 1rem 1.25rem;
  margin: 1rem 0;
  border-radius: 12px;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-left: 4px solid #4f46e5;
}

.status-indicator.thinking {
  border-left-color: #8b5cf6;
  background: #faf5ff;
}

.status-indicator.processing {
  border-left-color: #f59e0b;
  background: #fffbeb;
}

.status-indicator.typing {
  border-left-color: #10b981;
  background: #ecfdf5;
}

.status-content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.status-icon {
  font-size: 1.25rem;
  margin-right: 0.5rem;
}

.status-message {
  font-weight: 500;
  color: #374151;
  font-size: 0.9rem;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background: #e5e7eb;
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #4f46e5, #7c3aed);
  transition: width 0.3s ease;
  border-radius: 3px;
}

/* Flight Data Container */
.flight-data-container {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  line-height: 1.6;
  color: #374151;
}

.flight-section-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: 700;
  font-size: 1.1rem;
  color: #1f2937;
  margin: 1.5rem 0 0.75rem 0;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #e5e7eb;
}

.flight-section-header:first-child {
  margin-top: 0;
}

.section-emoji {
  font-size: 1.2rem;
}

.section-title {
  font-weight: 700;
}

.flight-data-line {
  display: flex;
  margin: 0.5rem 0;
  padding: 0.25rem 0;
}

.flight-data-key {
  font-weight: 600;
  color: #1f2937;
  min-width: 160px;
  flex-shrink: 0;
}

.flight-data-value {
  color: #374151;
  flex: 1;
}

.flight-data-text {
  margin: 0.5rem 0;
  padding: 0.25rem 0;
  color: #374151;
}

.flight-data-spacing {
  height: 0.75rem;
}

/* Responsive Design */
@media (max-width: 768px) {
  .app-container {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    max-height: 200px;
  }
  
  .sidebar-content {
    display: flex;
    overflow-x: auto;
    gap: 1rem;
  }
  
  .sidebar-section {
    flex-shrink: 0;
    margin-bottom: 0;
    min-width: 200px;
  }
  
  .indigo-gif-placeholder {
    display: none;
  }
  
  .chat-container {
    margin: 0.5rem;
    border-radius: 12px;
  }
  
  .messages-container {
    padding: 1rem;
  }
  
  .message-content {
    max-width: 85%;
    padding: 0.75rem 1rem;
  }
  
  .input-container {
    padding: 1rem;
  }
  
  .flight-data-line {
    flex-direction: column;
    gap: 0.25rem;
  }
  
  .flight-data-key {
    min-width: auto;
  }
}

@media (max-width: 480px) {
  .header h1 {
    font-size: 1.25rem;
  }
  
  .header img {
    height: 32px;
  }
  
  .message-content {
    max-width: 90%;
  }
  
  .flight-data-key {
    font-size: 0.9rem;
  }
  
  .flight-data-value {
    font-size: 0.9rem;
  }
}

/* Custom scrollbar for messages container */
.messages-container::-webkit-scrollbar {
  width: 6px;
}

.messages-container::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 3px;
}

.messages-container::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}

.messages-container::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}
#################################################################

/* App.css - complete stylesheet for FlightOps Chat UI */

/* Reset and base styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  height: 100vh;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #0f172a;
}

.app-container {
  display: flex;
  height: 100vh;
}

/* Sidebar Styles */
.sidebar {
  width: 250px;
  background: linear-gradient(180deg, #1e1b4b 0%, #312e81 100%);
  color: white;
  display: flex;
  flex-direction: column;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.12);
}

.sidebar-header {
  padding: 2rem 1.5rem 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.logo-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.logo-placeholder {
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, #818cf8, #4f46e5);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  margin-bottom: 1rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  color: white;
}

.sidebar-header h1 {
  font-size: 1.05rem;
  font-weight: 600;
  color: #e0e7ff;
}

.sidebar-content {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
}

.sidebar-section {
  margin-bottom: 2rem;
}

.sidebar-section h3 {
  font-size: 0.9rem;
  font-weight: 600;
  color: #a5b4fc;
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sidebar-btn {
  width: 100%;
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 8px;
  color: white;
  cursor: pointer;
  transition: all 0.22s ease;
  text-align: left;
  font-size: 0.92rem;
}

.sidebar-btn:hover {
  background: rgba(255, 255, 255, 0.14);
  transform: translateX(4px);
}

.recent-query {
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.04);
  border-radius: 6px;
  font-size: 0.85rem;
  color: #c7d2fe;
  border-left: 3px solid #818cf8;
}

/* Indigo GIF Placeholder */
.indigo-gif-placeholder {
  margin-top: auto;
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.04);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.gif-container {
  text-align: center;
}

.animated-plane {
  font-size: 3rem;
  margin-bottom: 1rem;
  animation: float 3s ease-in-out infinite;
  filter: drop-shadow(0 8px 16px rgba(0,0,0,0.15));
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50%    { transform: translateY(-10px); }
}

.gif-container p {
  color: #a5b4fc;
  font-size: 0.9rem;
  margin-bottom: 0.25rem;
}

/* Main Content */
.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #f8fafc;
  overflow: hidden;
}

.header {
  background: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  padding: 0.5rem 1.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Scrollbar Styling */
.sidebar-content::-webkit-scrollbar {
  width: 6px;
}

.sidebar-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.02);
}

.sidebar-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.15);
  border-radius: 8px;
}

/* Responsive Sidebar tweaks */
@media (max-width: 1000px) {
  .sidebar { width: 210px; }
}
@media (max-width: 768px) {
  .app-container { flex-direction: column; }
  .sidebar { width: 100%; height: auto; max-height: 200px; }
  .sidebar-content { display: flex; overflow-x: auto; gap: 1rem; }
  .indigo-gif-placeholder { display: none; }
}

/* Chat Container */
.chat-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: white;
  margin: 1rem;
  border-radius: 12px;
  box-shadow: 0 8px 30px rgba(2,6,23,0.06);
  overflow: hidden;
}

.messages-container {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
  background: #f8fafc;
}

/* Message Bubbles */
.message {
  margin-bottom: 1.25rem;
  display: flex;
  width: 100%;
}

.user-message {
  justify-content: flex-end;
}

.user-message .message-content {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border-bottom-right-radius: 6px;
}

.assistant-message .message-content {
  background: white;
  color: #374151;
  border: 1px solid #e6eef6;
  border-bottom-left-radius: 6px;
  box-shadow: 0 4px 16px rgba(15, 23, 42, 0.04);
}

/* Generic message content sizing */
.message-content {
  max-width: 60%;
  padding: 1rem 1.25rem;
  border-radius: 18px;
  position: relative;
  word-break: break-word;
  animation: slideIn 0.25s ease-out;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateY(8px); }
  to   { opacity: 1; transform: translateY(0); }
}

.message-text {
  line-height: 1.5;
  margin-bottom: 0.5rem;
  white-space: pre-wrap;
}

.message-timestamp {
  font-size: 0.75rem;
  opacity: 0.78;
  margin-top: 0.6rem;
}

.user-message .message-timestamp {
  text-align: right;
  color: rgba(255, 255, 255, 0.88);
}

.assistant-message .message-timestamp {
  text-align: left;
  color: #6b7280;
}

/* Loading Animation */
.loading-message {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin-bottom: 1.5rem;
}

.loading-dots {
  display: flex;
  gap: 0.25rem;
  padding: 1rem 1.25rem;
  background: white;
  border-radius: 18px;
  border: 1px solid #e6eef6;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #9ca3af;
  animation: bounce 1.4s infinite ease-in-out;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes bounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}

.loading-timestamp {
  font-size: 0.75rem;
  color: #6b7280;
  margin-top: 0.5rem;
  margin-left: 1.25rem;
}

/* Input Container */
.input-container {
  display: flex;
  gap: 0.75rem;
  padding: 1.25rem;
  background: white;
  border-top: 1px solid #eef2f7;
}

.message-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 1px solid #d1d5db;
  border-radius: 12px;
  font-size: 0.95rem;
  outline: none;
  transition: all 0.18s;
  background: white;
}

.message-input:focus {
  border-color: #4f46e5;
  box-shadow: 0 6px 18px rgba(79,70,229,0.08);
}

.send-button {
  padding: 0.75rem 1.5rem;
  background: linear-gradient(135deg, #4f46e5, #7c3aed);
  color: white;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.16s;
}

.send-button:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(79, 70, 229, 0.18);
}

.send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

/* Responsive */
@media (max-width: 768px) {
  .message-content { max-width: 85%; padding: 0.85rem 1rem; }
  .input-container { padding: 1rem; }
}

/* Statebar / Agent status */
.statebar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  border-bottom: 1px solid #eef2f7;
  background: #fff;
}

.statebar-left {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 160px;
}

.state-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: #10b981;
  box-shadow: 0 0 0 2px rgba(16,185,129,0.08);
}

.state-text {
  font-size: 0.9rem;
  color: #374151;
  text-transform: capitalize;
}

.statebar-progress {
  flex: 1;
  height: 6px;
  background: #f3f4f6;
  border-radius: 999px;
  overflow: hidden;
}

/* Small progress fill utility (used inline in components) */
.progress-bar { width: 100%; height: 6px; background: #e5e7eb; border-radius: 3px; overflow: hidden; }
.progress-fill { height: 100%; background: linear-gradient(90deg, #4f46e5, #7c3aed); transition: width 0.3s ease; border-radius: 3px; }

/* Status indicator variants */
.status-indicator {
  padding: 1rem 1.25rem;
  margin: 1rem 0;
  border-radius: 12px;
  background: #f8fafc;
  border: 1px solid #eaf2ff;
  border-left: 4px solid #4f46e5;
}

.status-indicator.thinking { border-left-color: #8b5cf6; background: #faf5ff; }
.status-indicator.processing { border-left-color: #f59e0b; background: #fffbeb; }
.status-indicator.typing { border-left-color: #10b981; background: #ecfdf5; }

.status-content { display: flex; flex-direction: column; gap: 0.5rem; }
.status-icon { font-size: 1.25rem; margin-right: 0.5rem; }
.status-message { font-weight: 500; color: #374151; }

/* ------------------------------------------------------------------
   Flight data & assistant summary styles (plain text, not markdown)
   ------------------------------------------------------------------*/

/* Flight Data Container */
.flight-data-container {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  line-height: 1.55;
  color: #0f172a;
  padding: 0.125rem 0;
  word-break: break-word;
}

/* Section Headers */
.flight-section-header {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  margin-top: 0.9rem;
  padding-bottom: 0.45rem;
  border-bottom: 1px solid #eef2f7;
}

.section-emoji {
  font-size: 1.05rem;
}

.section-title {
  font-weight: 700;
  color: #0f172a;
  font-size: 1rem;
}

/* First header spacing */
.flight-section-header:first-child { margin-top: 0; }

/* Data Lines */
.flight-data-line {
  display: flex;
  gap: 0.75rem;
  padding: 0.35rem 0;
  align-items: flex-start;
}

.flight-data-key {
  font-weight: 600;
  color: #0f172a;
  min-width: 140px;
  flex-shrink: 0;
}

.flight-data-value {
  color: #374151;
  flex: 1;
}

/* Regular Text */
.flight-data-text {
  margin: 0.35rem 0;
  padding: 0.25rem 0;
  color: #374151;
  white-space: pre-wrap;
}

/* Spacing */
.flight-data-spacing { height: 0.6rem; }

/* Performance & status classes */
.performance-good { color: #059669; font-weight: 600; }
.performance-average { color: #d97706; font-weight: 600; }
.performance-poor { color: #dc2626; font-weight: 600; }

.status-scheduled { color: #059669; font-weight: 600; }
.status-delayed   { color: #dc2626; font-weight: 600; }
.status-cancelled { color: #dc2626; font-weight: 600; }
.status-active    { color: #2563eb; font-weight: 600; }

/* Assistant summary card */
.assistant-summary {
  color: #0f172a;
  line-height: 1.5;
  padding: 0.25rem 0;
}

.assistant-summary-title {
  font-weight: 700;
  margin-bottom: 0.5rem;
  color: #0b3bff;
}

.assistant-summary-section {
  margin-bottom: 0.6rem;
}

.assistant-summary-paragraph {
  color: #374151;
  white-space: pre-wrap;
}

.assistant-bullets {
  margin: 0.25rem 0 0.5rem 1rem;
  color: #374151;
}

/* Token usage block (small inline card) */
.token-usage-block {
  padding: 0.6rem 0.8rem;
  border-top: 1px solid #eef2f7;
  font-size: 0.85rem;
  color: #374151;
}

/* small utility tweaks */
.small-muted { color: #6b7280; font-size: 0.82rem; }

/* final responsive tweaks */
@media (max-width: 520px) {
  .flight-data-key { min-width: 110px; font-size: 0.9rem; }
  .section-title { font-size: 0.95rem; }
  .message-content { padding: 0.8rem 0.95rem; }
  .logo-placeholder { width: 52px; height: 52px; }
}
###############################################

# client.py
import os
import json
import logging
import asyncio
from typing import List, Dict, Any

from dotenv import load_dotenv
from openai import AzureOpenAI
from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client

from tool_registry import TOOLS

# Load environment variables
load_dotenv()

MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://127.0.0.1:8000").rstrip("/")

# Azure OpenAI configuration
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-12-01-preview")

if not AZURE_OPENAI_KEY:
    raise RuntimeError("‚ùå AZURE_OPENAI_KEY not set in environment")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("FlightOps.MCPClient")

# Initialize Azure OpenAI client
client_azure = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version=AZURE_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)

# ---------------------------------------------------------------------
#  SYSTEM PROMPTS
# ---------------------------------------------------------------------
def _build_tool_prompt() -> str:
    """Convert TOOLS dict into compact text to feed the LLM."""
    lines = []
    for name, meta in TOOLS.items():
        arg_str = ", ".join(meta["args"])
        lines.append(f"- {name}({arg_str}): {meta['desc']}")
    return "\n".join(lines)


SYSTEM_PROMPT_PLAN = f"""
You are an assistant that converts user questions into MCP tool calls.

Available tools:
{_build_tool_prompt()}

... (same prompt as before) ...
"""

SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer.
Be factual, short, and helpful.
"""

# ---------------------------------------------------------------------
#  FLIGHTOPS MCP CLIENT CLASS
# ---------------------------------------------------------------------
class FlightOpsMCPClient:
    def __init__(self, base_url: str = None):
        self.base_url = (base_url or MCP_SERVER_URL).rstrip("/")
        self.session: ClientSession = None
        self._client_context = None

    # -------------------- CONNECTION HANDLERS -------------------------
    async def connect(self):
        try:
            logger.info(f"Connecting to MCP server at {self.base_url}")
            self._client_context = streamablehttp_client(self.base_url)
            read_stream, write_stream, _ = await self._client_context.__aenter__()
            self.session = ClientSession(read_stream, write_stream)
            await self.session.__aenter__()
            await self.session.initialize()
            logger.info("‚úÖ Connected to MCP server successfully")
        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            raise

    async def disconnect(self):
        try:
            if self.session:
                await self.session.__aexit__(None, None, None)
            if self._client_context:
                await self._client_context.__aexit__(None, None, None)
            logger.info("Disconnected from MCP server")
        except Exception as e:
            logger.error(f"Error during disconnect: {e}")

    # -------------------- AZURE OPENAI WRAPPER -------------------------
    def _call_azure_openai(self, messages: list, temperature: float = 0.2, max_tokens: int = 2048) -> dict:
        """
        Call Azure OpenAI, return dict { content: str, usage: {prompt_tokens, completion_tokens, total_tokens} }
        """
        try:
            completion = client_azure.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            usage_obj = getattr(completion, "usage", None)
            usage = None
            if usage_obj is not None:
                usage = {
                    "prompt_tokens": getattr(usage_obj, "prompt_tokens", None),
                    "completion_tokens": getattr(usage_obj, "completion_tokens", None),
                    "total_tokens": getattr(usage_obj, "total_tokens", None),
                }
            return {
                "content": completion.choices[0].message.content,
                "usage": usage
            }
        except Exception as e:
            logger.error(f"Azure OpenAI API error: {e}")
            return {"content": json.dumps({"error": str(e)}), "usage": None}

    # -------------------- MCP TOOL CALLS -------------------------
    async def list_tools(self) -> dict:
        try:
            if not self.session:
                await self.connect()
            tools_list = await self.session.list_tools()
            tools_dict = {tool.name: {"description": tool.description, "inputSchema": tool.inputSchema} for tool in tools_list.tools}
            return {"tools": tools_dict}
        except Exception as e:
            logger.error(f"Error listing tools: {e}")
            return {"error": str(e)}

    async def invoke_tool(self, tool_name: str, args: dict) -> dict:
        try:
            if not self.session:
                await self.connect()
            logger.info(f"Calling tool: {tool_name} with args: {args}")
            result = await self.session.call_tool(tool_name, args)

            if result.content:
                content_items = []
                for item in result.content:
                    if hasattr(item, 'text'):
                        try:
                            content_items.append(json.loads(item.text))
                        except json.JSONDecodeError:
                            content_items.append(item.text)
                if len(content_items) == 1:
                    return content_items[0]
                return {"results": content_items}

            return {"error": "No content in response"}
        except Exception as e:
            logger.error(f"Error invoking tool {tool_name}: {e}")
            return {"error": str(e)}

    # -------------------- LLM PLANNING & SUMMARIZATION -------------------------
    def plan_tools(self, user_query: str) -> dict:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_PLAN},
            {"role": "user", "content": user_query},
        ]

        res = self._call_azure_openai(messages, temperature=0.1)
        content = res.get("content")
        plan_usage = res.get("usage")
        if not content:
            logger.warning("‚ö†Ô∏è LLM returned empty response during plan generation.")
            return {"plan": [], "llm_usage": plan_usage}

        cleaned = content.strip()
        if cleaned.startswith("```"):
            cleaned = cleaned.strip("`")
            if cleaned.lower().startswith("json"):
                cleaned = cleaned[4:].strip()
            cleaned = cleaned.replace("```", "").strip()

        if cleaned != content:
            logger.debug(f"üîç Cleaned LLM plan output:\n{cleaned}")

        try:
            plan = json.loads(cleaned)
            if isinstance(plan, dict) and "plan" in plan:
                return {"plan": plan["plan"], "llm_usage": plan_usage}
            else:
                logger.warning("‚ö†Ô∏è LLM output did not contain 'plan' key.")
                return {"plan": [], "llm_usage": plan_usage}
        except json.JSONDecodeError:
            logger.warning(f"‚ùå Could not parse LLM plan output after cleaning:\n{cleaned}")
            return {"plan": [], "llm_usage": plan_usage}

    def summarize_results(self, user_query: str, plan: list, results: list) -> dict:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARIZE},
            {"role": "user", "content": f"Question:\n{user_query}"},
            {"role": "assistant", "content": f"Plan:\n{json.dumps(plan, indent=2)}"},
            {"role": "assistant", "content": f"Results:\n{json.dumps(results, indent=2)}"},
        ]
        res = self._call_azure_openai(messages, temperature=0.3)
        return {"summary": res.get("content"), "llm_usage": res.get("usage")}

    async def run_query(self, user_query: str) -> dict:
        try:
            logger.info(f"User query: {user_query}")
            plan_data = self.plan_tools(user_query)
            plan = plan_data.get("plan", [])
            planning_usage = plan_data.get("llm_usage")
            if not plan:
                return {"error": "LLM did not produce a valid tool plan.", "token_usage": {"planning": planning_usage}}

            results = []
            for step in plan:
                tool = step.get("tool")
                args = step.get("arguments", {})

                # Clean up bad args
                args = {k: v for k, v in args.items() if v and str(v).strip().lower() != "unknown"}

                # Safety for MongoDB query
                if tool == "raw_mongodb_query":
                    query_json = args.get("query_json", "")
                    if not query_json:
                        results.append({"raw_mongodb_query": {"error": "Empty query_json"}})
                        continue
                    # Enforce safe default limit
                    args["limit"] = int(args.get("limit", 50))
                    logger.info(f"Executing raw MongoDB query: {query_json}")

                resp = await self.invoke_tool(tool, args)
                results.append({tool: resp})

            summary = self.summarize_results(user_query, plan, results)
            summarization_usage = summary.get("llm_usage")

            def _safe_int(x):
                try:
                    return int(x) if x is not None else 0
                except:
                    return 0

            total = {
                "prompt_tokens": _safe_int(planning_usage and planning_usage.get("prompt_tokens")) +
                                 _safe_int(summarization_usage and summarization_usage.get("prompt_tokens")),
                "completion_tokens": _safe_int(planning_usage and planning_usage.get("completion_tokens")) +
                                     _safe_int(summarization_usage and summarization_usage.get("completion_tokens")),
                "total_tokens": _safe_int(planning_usage and planning_usage.get("total_tokens")) +
                                _safe_int(summarization_usage and summarization_usage.get("total_tokens")),
            }

            return {
                "plan": plan,
                "results": results,
                "summary": {"summary": summary.get("summary")},
                "token_usage": {
                    "planning": planning_usage,
                    "summarization": summarization_usage,
                    "total": total
                }
            }
        except Exception as e:
            logger.error(f"Error in run_query: {e}")
            return {"error": str(e)}
#################################################
# ag_ui_adapter.py
import os
import json
import asyncio
import time
import uuid
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],           # lock down in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        # don't crash; /health will reflect status
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    """
    Split text into small chunks for streaming as typing.
    Prefer sentence boundaries; fallback by length.
    """
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        # flush at sentence end or when too long
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

def format_flight_data(raw_text: str) -> str:
    """
    Convert raw flight data (possibly produced by the LLM) into a clean plain-text format.
    Removes duplicate keys and produces sectioned readable output (no Markdown).
    """
    if not raw_text:
        return "‚úàÔ∏è Flight Information\n\nNo data available."

    lines = raw_text.splitlines()
    flight_info = {}

    for line in lines:
        line = line.strip()
        if not line:
            continue
        if ':' in line:
            clean = line.lstrip('-* ').strip()
            key_part, value_part = clean.split(':', 1)
            key = key_part.strip()
            value = value_part.strip().replace('*', '')
            if key and key not in flight_info:
                flight_info[key] = value

    if not flight_info:
        seen = set()
        out_lines = []
        for ln in lines:
            ln_clean = ln.replace('*', '').strip()
            if ln_clean and ln_clean not in seen:
                seen.add(ln_clean)
                out_lines.append(ln_clean)
        return "‚úàÔ∏è Flight Information\n\n" + "\n".join(out_lines)

    out = []
    out.append("‚úàÔ∏è Flight Information\n")
    out.append("üìã Basic Details")
    if 'Carrier' in flight_info:
        out.append(f"Carrier: {flight_info['Carrier']}")
    if 'Flight Number' in flight_info:
        out.append(f"Flight Number: {flight_info['Flight Number']}")
    if 'Date' in flight_info:
        out.append(f"Date: {flight_info['Date']}")
    if 'Route' in flight_info:
        out.append(f"Route: {flight_info['Route']}")
    out.append("")

    out.append("üïê Schedule & Timing")
    if 'Scheduled Departure' in flight_info:
        out.append(f"Departure: {flight_info['Scheduled Departure']}")
    if 'Scheduled Arrival' in flight_info:
        out.append(f"Arrival: {flight_info['Scheduled Arrival']}")
    if 'Scheduled Block Time' in flight_info:
        out.append(f"Scheduled Duration: {flight_info['Scheduled Block Time']}")
    if 'Actual Block Time' in flight_info:
        out.append(f"Actual Duration: {flight_info['Actual Block Time']}")
    out.append("")

    out.append("üìä Flight Status")
    if 'Flight Type' in flight_info:
        out.append(f"Type: {flight_info['Flight Type']}")
    if 'Operational Status' in flight_info:
        status = flight_info['Operational Status']
        status_emoji = "‚úÖ" if "Scheduled" in status or "On Time" in status else "‚ö†Ô∏è" if "Delayed" in status else "üîÑ"
        out.append(f"Status: {status_emoji} {status}")

    if 'Scheduled Block Time' in flight_info and 'Actual Block Time' in flight_info:
        try:
            scheduled = flight_info['Scheduled Block Time']
            actual = flight_info['Actual Block Time']
            if scheduled and actual and scheduled != actual:
                out.append("")
                out.append("üìà Performance")
                if "ahead" in raw_text.lower() or "earlier" in raw_text.lower():
                    out.append("üü¢ Flight arrived ahead of schedule.")
                else:
                    out.append("Performance info available in details above.")
        except Exception:
            pass

    return "\n".join(out)

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    """
    AG-UI compatible streaming endpoint (SSE).
    Expected body:
      {
        thread_id?, run_id?,
        messages: [{role, content}, ...],
        tools?: []
      }
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])

    # last user message as query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query found")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})

        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {
                "phase": "thinking",
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {
                "phase": "thinking",
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })

        try:
            # plan_tools returns {"plan": [...], "llm_usage": {...}} in the updated client
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        planning_usage = plan_data.get("llm_usage") if isinstance(plan_data, dict) else None

        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {
                "phase": "processing",
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps  # 20% to 80%
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            # Update processing status for current tool
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"

            # Tool call events
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            # call tool
            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
            except Exception as exc:
                tool_result = {"error": str(exc)}

            # result
            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            # update progress
            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))

            # heartbeat every ~15s while long tools run
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {
                "phase": "typing",
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            # summarize_results returns {"summary": "...", "llm_usage": {...}}
            summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
            summarization_usage = summary_obj.get("llm_usage") if isinstance(summary_obj, dict) else None
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"
            summarization_usage = None

        # Emit token usage event (planning + summarization)
        yield sse_event({"type": "TOKEN_USAGE", "token_usage": {"planning": planning_usage, "summarization": summarization_usage}})

        # Optionally format assistant_text to plain flight data if it looks like flight info
        # Very small heuristic: if assistant_text contains 'Flight Number' or 'Scheduled'
        formatted_text = assistant_text
        if any(k in (assistant_text or "") for k in ("Flight Number", "Scheduled Departure", "Route", "Flight Information", "üìã")):
            try:
                formatted_text = format_flight_data(assistant_text)
            except Exception:
                formatted_text = assistant_text

        # Stream summary as chunks (typing effect)
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"

        # Start the message
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""  # Start with empty content
            }
        })

        # Stream chunks with typing effect
        chunks = chunk_text(formatted_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant",
                    "delta": chunk  # AG-UI delta for streaming
                }
            })

            # Update typing progress
            typing_progress = 85 + (i / max(1, len(chunks))) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })

            await asyncio.sleep(0.03)  # Typing speed

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE",
            "state": {
                "phase": "finished",
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
#######################################################
// src/components/MessageBubble.jsx
import React from "react";

export default function MessageBubble({ role, content, timestamp }) {
  content = content || "";

  const isFlightData =
    typeof content === "string" &&
    (content.includes("Flight Information") ||
      content.includes("Flight Number") ||
      content.includes("Scheduled Departure") ||
      content.includes("Route:") ||
      content.includes("üìã Basic Details"));

  const isAssistantSummary =
    role === "assistant" &&
    typeof content === "string" &&
    (content.includes("\n\n") || content.includes("‚Ä¢") || content.includes("- "));

  function renderFlightData(text) {
    const lines = text.split("\n");
    return (
      <div className="flight-data-container">
        {lines.map((ln, i) => {
          const line = ln.trim();
          if (!line) return <div key={i} className="flight-data-spacing" />;

          if (
            line.startsWith("‚úàÔ∏è") ||
            line.startsWith("üìã") ||
            line.startsWith("üïê") ||
            line.startsWith("üìä") ||
            line.startsWith("üìà")
          ) {
            const emoji = line.charAt(0);
            const title = line.slice(1).trim();
            return (
              <div key={i} className="flight-section-header">
                <span className="section-emoji">{emoji}</span>
                <span className="section-title">{title}</span>
              </div>
            );
          }

          if (line.includes(":")) {
            const [k, ...rest] = line.split(":");
            const v = rest.join(":").trim();
            return (
              <div key={i} className="flight-data-line">
                <div className="flight-data-key">{k.trim()}:</div>
                <div className="flight-data-value">{v}</div>
              </div>
            );
          }

          return (
            <div key={i} className="flight-data-text">
              {line}
            </div>
          );
        })}
      </div>
    );
  }

  function renderAssistantSummary(text) {
    const parts = text.split(/\n{2,}/).map((p) => p.trim()).filter(Boolean);

    return (
      <div className="assistant-summary">
        {parts.map((p, idx) => {
          if (p.includes("‚Ä¢") || p.includes("- ")) {
            const lines = p.split("\n").map((l) => l.replace(/^[\-\u2022]\s*/, "").trim()).filter(Boolean);
            return (
              <div key={idx} className="assistant-summary-section">
                {idx === 0 && <div className="assistant-summary-title">Summary</div>}
                <ul className="assistant-bullets">
                  {lines.map((li, i) => (
                    <li key={i}>{li}</li>
                  ))}
                </ul>
              </div>
            );
          }

          return (
            <div key={idx} className="assistant-summary-section">
              {idx === 0 && <div className="assistant-summary-title">Summary</div>}
              <div className="assistant-summary-paragraph">{p}</div>
            </div>
          );
        })}
      </div>
    );
  }

  return (
    <div className={`message ${role}-message`}>
      <div className="message-content">
        {role === "assistant" && isFlightData ? (
          renderFlightData(content)
        ) : role === "assistant" && isAssistantSummary ? (
          renderAssistantSummary(content)
        ) : role === "assistant" ? (
          <div className="assistant-text" style={{ whiteSpace: "pre-wrap" }}>
            {content}
          </div>
        ) : (
          <div className="user-text" style={{ whiteSpace: "pre-wrap" }}>
            {content}
          </div>
        )}

        <div className="message-timestamp">{timestamp}</div>
      </div>
    </div>
  );
}
###########################################3
// src/components/ChatPage.jsx
import React, { useState, useRef, useEffect } from "react";
import MessageBubble from "./MessageBubble";

const AG_AGENT_ENDPOINT = import.meta.env.VITE_AGENT_ENDPOINT || "http://localhost:8001/agent";

export default function ChatPage() {
    const [messages, setMessages] = useState([
        {
            role: "assistant",
            content: "Hello! üëã I'm your FlightOps Agent. Ask me anything about flight operations ‚Äî delays, fuel, passengers, aircraft details, etc.",
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        },
    ]);
    const [input, setInput] = useState("");
    const [loading, setLoading] = useState(false);
    const [agentState, setAgentState] = useState({
        phase: 'idle',
        progress: 0,
        message: ''
    });
    const [tokenUsage, setTokenUsage] = useState(null);
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    async function sendMessage() {
        if (!input.trim()) return;

        const userMessage = { 
            role: "user", 
            content: input,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };
        setMessages((prev) => [...prev, userMessage]);
        setLoading(true);
        setInput("");
        setTokenUsage(null);

        setAgentState({
            phase: 'thinking',
            progress: 0,
            message: 'Starting analysis...'
        });

        const body = {
            thread_id: "thread-" + Date.now(),
            run_id: "run-" + Date.now(),
            messages: [userMessage],
        };

        try {
            const resp = await fetch(AG_AGENT_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });

            if (!resp.ok) {
                const errTxt = await resp.text();
                throw new Error(errTxt);
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let buf = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buf += decoder.decode(value, { stream: true });

                let idx;
                while ((idx = buf.indexOf("\n\n")) !== -1) {
                    const chunk = buf.slice(0, idx).trim();
                    buf = buf.slice(idx + 2);
                    const lines = chunk.split("\n");

                    for (const line of lines) {
                        if (line.startsWith("data: ")) {
                            const payload = line.slice(6).trim();
                            if (!payload) continue;

                            try {
                                const event = JSON.parse(payload);
                                handleEvent(event);
                            } catch (err) {
                                console.warn("Bad SSE line:", payload);
                            }
                        }
                    }
                }
            }
        } catch (err) {
            setMessages((prev) => [
                ...prev,
                { 
                    role: "assistant", 
                    content: "‚ö†Ô∏è Error: " + err.message,
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                },
            ]);
            setAgentState({ phase: 'idle', progress: 0, message: '' });
        } finally {
            setLoading(false);
        }
    }

    function handleEvent(event) {
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

        switch (event.type) {
            case "STATE_UPDATE":
                setAgentState(event.state);
                break;

            case "TEXT_MESSAGE_CONTENT":
                if (event.message) {
                    if (event.message.delta) {
                        setMessages(prev => {
                            const existingIdx = prev.findIndex(m => m.id === event.message.id);
                            if (existingIdx >= 0) {
                                const updated = [...prev];
                                updated[existingIdx].content += event.message.delta;
                                updated[existingIdx].timestamp = timestamp;
                                return updated;
                            } else {
                                return [...prev, {
                                    id: event.message.id,
                                    role: event.message.role,
                                    content: event.message.delta,
                                    timestamp: timestamp
                                }];
                            }
                        });
                    } else if (event.message.content) {
                        setMessages(prev => [...prev, {
                            id: event.message.id,
                            role: event.message.role,
                            content: event.message.content,
                            timestamp: timestamp
                        }]);
                    }
                } else if (event.content) {
                    setMessages(prev => [...prev, {
                        role: "assistant",
                        content: event.content,
                        timestamp: timestamp
                    }]);
                }
                break;

            case "TOOL_CALL_START":
                setMessages(prev => [...prev, {
                    role: "system",
                    content: `üõ†Ô∏è Starting ${event.toolCallName}...`,
                    timestamp: timestamp
                }]);
                break;

            case "TOKEN_USAGE":
                // event.token_usage is { planning: {...}, summarization: {...} }
                setTokenUsage(event.token_usage || null);
                break;

            case "RUN_FINISHED":
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;

            case "RUN_ERROR":
                setMessages(prev => [...prev, {
                    role: "assistant",
                    content: "‚ùå " + event.error,
                    timestamp: timestamp
                }]);
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;

            default:
                break;
        }
    }

    const StatusIndicator = () => {
        if (agentState.phase === 'idle') return null;

        const phaseIcons = {
            thinking: 'üß†',
            processing: 'üõ†Ô∏è',
            typing: '‚úçÔ∏è',
            finished: '‚úÖ'
        };

        return (
            <div className={`status-indicator ${agentState.phase}`}>
                <div className="status-content">
                    <div style={{display:'flex', alignItems:'center', gap:8}}>
                        <span className="status-icon">{phaseIcons[agentState.phase]}</span>
                        <span className="status-message">{agentState.message}</span>
                    </div>
                    {agentState.progress > 0 && (
                        <div className="progress-bar" style={{marginTop:8}}>
                            <div 
                                className="progress-fill"
                                style={{ width: `${agentState.progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    // Token usage display
    const TokenUsageBlock = ({ usage }) => {
        if (!usage) return null;
        const planning = usage.planning || {};
        const summarization = usage.summarization || {};
        const total = usage.total || {};
        return (
            <div style={{padding: '8px 12px', borderTop: '1px solid #eee', fontSize: 12, color: '#374151'}}>
                <div style={{fontWeight:600}}>LLM token usage</div>
                <div style={{display:'flex', gap:12, marginTop:6}}>
                    <div>Planning: {planning && planning.total_tokens ? planning.total_tokens : '-'}</div>
                    <div>Summarization: {summarization && summarization.total_tokens ? summarization.total_tokens : '-'}</div>
                    <div>Total: {total && total.total_tokens ? total.total_tokens : (total && total.total_tokens === 0 ? 0 : (total && (total.prompt_tokens || total.completion_tokens) ? (Number(total.prompt_tokens||0)+Number(total.completion_tokens||0)) : '-'))}</div>
                </div>
            </div>
        );
    };

    return (
        <div className="chat-container">
            <div className="messages-container">
                {messages.map((msg, idx) => (
                    <MessageBubble 
                        key={msg.id || idx} 
                        role={msg.role} 
                        content={msg.content} 
                        timestamp={msg.timestamp}
                    />
                ))}

                <StatusIndicator />

                {tokenUsage && <TokenUsageBlock usage={tokenUsage} />}

                {loading && agentState.phase === 'idle' && (
                    <div className="loading-message">
                        <div className="loading-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div className="loading-timestamp">
                            {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            <div className="input-container">
                <input
                    type="text"
                    className="message-input"
                    placeholder="Ask about a flight, e.g. 'Why was 6E215 delayed on June 23, 2024?'"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === "Enter" && sendMessage()}
                    disabled={loading}
                />
                <button
                    onClick={sendMessage}
                    className="send-button"
                    disabled={loading}
                >
                    Send
                </button>
            </div>
        </div>
    );
}
################################################
/* Flight Data Container */
.flight-data-container {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.55;
  color: #111827;
  padding: 0.2rem 0;
}

/* Section Headers */
.flight-section-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.75rem;
  padding-bottom: 0.35rem;
  border-bottom: 1px solid #eef2f7;
}
.section-emoji { font-size: 1.1rem; }
.section-title { font-weight: 700; color: #0f172a; }

/* Data lines */
.flight-data-line { display: flex; gap: 0.75rem; padding: 0.375rem 0; align-items: flex-start; }
.flight-data-key { min-width: 140px; color: #0f172a; font-weight: 600; flex-shrink: 0; }
.flight-data-value { color: #374151; flex: 1; }
.flight-data-spacing { height: 0.6rem; }

/* Assistant summary */
.assistant-summary { color: #111827; line-height: 1.5; }
.assistant-summary-title { font-weight: 700; margin-bottom: 0.5rem; color: #0b3bff; }
.assistant-summary-section { margin-bottom: 0.75rem; }
.assistant-summary-paragraph { color: #374151; }
.assistant-bullets { margin: 0.25rem 0 0.5rem 1rem; color: #374151; }

/* Keep message-content sizing comfortable for flight cards */
.message-content { max-width: 78%; padding: 1rem 1.1rem; border-radius: 12px; }
@media (max-width: 768px) { .message-content { max-width: 92%; } }
##############################################################

# server.py
import os
import logging
import json
from typing import Optional, Any, Dict
from datetime import datetime
from motor.motor_asyncio import AsyncIOMotorClient
from dotenv import load_dotenv
load_dotenv() 

from mcp.server.fastmcp import FastMCP

HOST = os.getenv("MCP_HOST", "127.0.0.1")
PORT = int(os.getenv("MCP_PORT", "8000"))
TRANSPORT = os.getenv("MCP_TRANSPORT", "streamable-http")

MONGODB_URL = os.getenv("MONGO_URI")
DATABASE_NAME = os.getenv("MONGO_DB")
COLLECTION_NAME = os.getenv("MONGO_COLLECTION")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("flightops.mcp.server")

mcp = FastMCP("FlightOps MCP Server")

_mongo_client: Optional[AsyncIOMotorClient] = None
_db = None
_col = None

async def get_mongodb_client():
    """Initialize and return the global Motor client, DB and collection."""
    global _mongo_client, _db, _col
    if _mongo_client is None:
        logger.info("Connecting to MongoDB: %s", MONGODB_URL)
        _mongo_client = AsyncIOMotorClient(MONGODB_URL)
        _db = _mongo_client[DATABASE_NAME]
        _col = _db[COLLECTION_NAME]
    return _mongo_client, _db, _col

def normalize_flight_number(flight_number: Any) -> Optional[int]:
    """Convert flight_number to int. MongoDB stores it as int."""
    if flight_number is None or flight_number == "":
        return None
    if isinstance(flight_number, int):
        return flight_number
    try:
        return int(str(flight_number).strip())
    except (ValueError, TypeError):
        logger.warning(f"Could not normalize flight_number: {flight_number}")
        return None

def validate_date(date_str: str) -> Optional[str]:
    """
    Validate date_of_origin string. Accepts common formats.
    Returns normalized ISO date string YYYY-MM-DD if valid, else None.
    """
    if not date_str or date_str == "":
        return None
    
    # Handle common date formats
    formats = [
        "%Y-%m-%d",      # 2024-06-23
        "%d-%m-%Y",      # 23-06-2024
        "%Y/%m/%d",      # 2024/06/23
        "%d/%m/%Y",      # 23/06/2024
        "%B %d, %Y",     # June 23, 2024
        "%d %B %Y",      # 23 June 2024
        "%b %d, %Y",     # Jun 23, 2024
        "%d %b %Y"       # 23 Jun 2024
    ]
    
    for fmt in formats:
        try:
            dt = datetime.strptime(date_str, fmt)
            return dt.strftime("%Y-%m-%d")
        except ValueError:
            continue
    
    logger.warning(f"Could not parse date: {date_str}")
    return None

def make_query(carrier: str, flight_number: Optional[int], date_of_origin: str) -> Dict:
    """
    Build MongoDB query matching the actual database schema.
    """
    query = {}
    
    # Add carrier if provided
    if carrier:
        query["flightLegState.carrier"] = carrier
    
    # Add flight number as integer (as stored in DB)
    if flight_number is not None:
        query["flightLegState.flightNumber"] = flight_number
    
    # Add date if provided
    if date_of_origin:
        query["flightLegState.dateOfOrigin"] = date_of_origin
    
    logger.info(f"Built query: {json.dumps(query)}")
    return query

def response_ok(data: Any) -> str:
    """Return JSON string for successful response."""
    return json.dumps({"ok": True, "data": data}, indent=2, default=str)

def response_error(msg: str, code: int = 400) -> str:
    """Return JSON string for error response."""
    return json.dumps({"ok": False, "error": {"message": msg, "code": code}}, indent=2)

async def _fetch_one_async(query: dict, projection: dict) -> str:          #  Point of concern
    """
    Consistent async DB fetch and error handling.
    Returns JSON string response.
    """
    try:
        _, _, col = await get_mongodb_client()
        logger.info(f"Executing query: {json.dumps(query)}")
        
        result = await col.find_one(query, projection)
        
        if not result:
            logger.warning(f"No document found for query: {json.dumps(query)}")
            return response_error("No matching document found.", code=404)
        
        # Remove _id and _class to keep output clean
        if "_id" in result:
            result.pop("_id")
        if "_class" in result:
            result.pop("_class")
        
        logger.info(f"Query successful")
        return response_ok(result)
    except Exception as exc:
        logger.exception("DB query failed")
        return response_error(f"DB query failed: {str(exc)}", code=500)

# --- MCP Tools ---

@mcp.tool()
async def health_check() -> str:
    """
    Simple health check for orchestrators and clients.
    Attempts a cheap DB ping.
    """
    try:
        _, _, col = await get_mongodb_client()
        doc = await col.find_one({}, {"_id": 1})
        return response_ok({"status": "ok", "db_connected": doc is not None})
    except Exception as e:
        logger.exception("Health check DB ping failed")
        return response_error("DB unreachable", code=503)

@mcp.tool()
async def get_flight_basic_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Fetch basic flight information including carrier, flight number, date, stations, times, and status.
    
    Args:
        carrier: Airline carrier code (e.g., "6E", "AI")
        flight_number: Flight number as string (e.g., "215")
        date_of_origin: Date in YYYY-MM-DD format (e.g., "2024-06-23")
    """
    logger.info(f"get_flight_basic_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    # Normalize inputs
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date_of_origin format. Expected YYYY-MM-DD or common date formats", 400)
    
    query = make_query(carrier, fn, dob)
    
    # Project basic flight information
    projection = {
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.suffix": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.seqNumber": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.startStationICAO": 1,
        "flightLegState.endStationICAO": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.flightStatus": 1,
        "flightLegState.operationalStatus": 1,
        "flightLegState.flightType": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1,
        "flightLegState.isOTPFlight": 1,
        "flightLegState.isOTPAchieved": 1,
        "flightLegState.isOTPConsidered": 1,
        "flightLegState.isOTTFlight": 1,
        "flightLegState.isOTTAchievedFlight": 1,
        "flightLegState.turnTimeFlightBeforeActual": 1,
        "flightLegState.turnTimeFlightBeforeSch": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_operation_times(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Return estimated and actual operation times for a flight including takeoff, landing, block times,StartTimeOffset, EndTimeOffset.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_operation_times: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    if date_of_origin and not dob:
        return response_error("Invalid date format.", 400)
    
    query = make_query(carrier, fn, dob)
    
    projection = {
       
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.scheduledEndTime": 1,
        "flightLegState.startTimeOffset": 1,
        "flightLegState.endTimeOffset": 1,
        "flightLegState.operation.estimatedTimes": 1,
        "flightLegState.operation.actualTimes": 1,
        "flightLegState.taxiOutTime": 1,
        "flightLegState.taxiInTime": 1,
        "flightLegState.blockTimeSch": 1,
        "flightLegState.blockTimeActual": 1,
        "flightLegState.flightHoursActual": 1,
        
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_equipment_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get aircraft equipment details including aircraft type, registration (tail number), and configuration.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_equipment_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.equipment.plannedAircraftType": 1,
        "flightLegState.equipment.aircraft": 1,
        "flightLegState.equipment.aircraftConfiguration": 1,
        "flightLegState.equipment.aircraftRegistration": 1,
        "flightLegState.equipment.assignedAircraftTypeIATA": 1,
        "flightLegState.equipment.assignedAircraftTypeICAO": 1,
        "flightLegState.equipment.assignedAircraftTypeIndigo": 1,
        "flightLegState.equipment.assignedAircraftConfiguration": 1,
        "flightLegState.equipment.tailLock": 1,
        "flightLegState.equipment.onwardFlight": 1,
        "flightLegState.equipment.actualOnwardFlight": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_delay_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Summarize delay reasons, durations, and total delay time for a specific flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_delay_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
   
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.scheduledStartTime": 1,
        "flightLegState.operation.actualTimes.offBlock": 1,
        "flightLegState.delays": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_fuel_summary(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Retrieve fuel summary including planned vs actual fuel for takeoff, landing, and total consumption.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_fuel_summary: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
       
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.startStation": 1,
        "flightLegState.endStation": 1,
        "flightLegState.operation.fuel": 1,
        "flightLegState.operation.flightPlan.offBlockFuel": 1,
        "flightLegState.operation.flightPlan.takeoffFuel": 1,
        "flightLegState.operation.flightPlan.landingFuel": 1,
        "flightLegState.operation.flightPlan.holdFuel": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_passenger_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get passenger count and connection information for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_passenger_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.pax": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def get_crew_info(carrier: str = "", flight_number: str = "", date_of_origin: str = "") -> str:
    """
    Get crew connections and details for the flight.
    
    Args:
        carrier: Airline carrier code
        flight_number: Flight number as string
        date_of_origin: Date in YYYY-MM-DD format
    """
    logger.info(f"get_crew_info: carrier={carrier}, flight_number={flight_number}, date={date_of_origin}")
    
    fn = normalize_flight_number(flight_number) if flight_number else None
    dob = validate_date(date_of_origin) if date_of_origin else None
    
    query = make_query(carrier, fn, dob)
    
    projection = {
        
        "flightLegState.carrier": 1,
        "flightLegState.flightNumber": 1,
        "flightLegState.dateOfOrigin": 1,
        "flightLegState.crewConnections": 1
    }
    
    return await _fetch_one_async(query, projection)

@mcp.tool()
async def raw_mongodb_query(query_json: str, projection: str = "", limit: int = 10) -> str:
    """
    Execute a raw MongoDB query (stringified JSON) with optional projection.

    Supports intelligent LLM-decided projections to reduce payload size based on query intent.

    Args:
        query_json: The MongoDB query (as stringified JSON).
        projection: Optional projection (as stringified JSON) for selecting fields.
        limit: Max number of documents to return (default 10, capped at 50).
    """

    def _safe_json_loads(text: str) -> dict:
        """Safely parse JSON, handling single quotes and formatting errors."""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            try:
                fixed = text.replace("'", '"')
                return json.loads(fixed)
            except Exception as e:
                raise ValueError(f"Invalid JSON: {e}")

    try:
        _, _, col = await get_mongodb_client()

        # --- Parse Query ---
        try:
            query = _safe_json_loads(query_json)
        except ValueError as e:
            return response_error(f"‚ùå Invalid query_json: {str(e)}", 400)

        # --- Parse Projection (optional) ---
        projection_dict = None
        if projection:
            try:
                projection_dict = _safe_json_loads(projection)
            except ValueError as e:
                return response_error(f"‚ùå Invalid projection JSON: {str(e)}", 400)

        # --- Validate types ---
        if not isinstance(query, dict):
            return response_error("‚ùå query_json must be a JSON object.", 400)
        if projection_dict and not isinstance(projection_dict, dict):
            return response_error("‚ùå projection must be a JSON object.", 400)

        # --- Safety guard ---
        forbidden_ops = ["$where", "$out", "$merge", "$accumulator", "$function"]
        for key in query.keys():
            if key in forbidden_ops or key.startswith("$"):
                return response_error(f"‚ùå Operator '{key}' is not allowed.", 400)

        limit = min(max(1, int(limit)), 50)

        # --- Fallback projection ---
        # If the LLM forgets to include projection, return a minimal safe set.
        if not projection_dict:
            projection_dict = {
                "_id": 0,
                "flightLegState.carrier": 1,
                "flightLegState.flightNumber": 1,
                "flightLegState.dateOfOrigin": 1
            }
            
        logger.info(f"Executing MongoDB query: {query} | projection={projection_dict} | limit={limit}")

        # --- Run query ---
        cursor = col.find(query, projection_dict).sort("flightLegState.dateOfOrigin", -1).limit(limit)
        docs = []
        async for doc in cursor:
            doc.pop("_id", None)
            doc.pop("_class", None)
            docs.append(doc)

        if not docs:
            return response_error("No documents found for the given query.", 404)

        return response_ok({
            "count": len(docs),
            "query": query,
            "projection": projection_dict,
            "documents": docs
        })

    except Exception as exc:
        logger.exception("‚ùå raw_mongodb_query failed")
        return response_error(f"Raw MongoDB query failed: {str(exc)}", 500)


@mcp.tool()
async def run_aggregated_query(
    query_type: str = "",
    carrier: str = "",
    field: str = "",
    start_date: str = "",
    end_date: str = "",
    filter_json: str = ""
) -> str:
    """
    Run statistical or comparative MongoDB aggregation queries.

    Args:
        query_type: "average", "sum", "min", "max", "count".
        carrier: Optional carrier filter.
        field: Field to aggregate, e.g. "flightLegState.pax.passengerCount.count".
        start_date: Optional start date (YYYY-MM-DD).
        end_date: Optional end date (YYYY-MM-DD).
        filter_json: Optional filter query (as JSON string).
    """

    _, _, col = await get_mongodb_client()

    match_stage = {}

    # --- Optional filters ---
    if filter_json:
        try:
            match_stage.update(json.loads(filter_json.replace("'", '"')))
        except Exception as e:
            return response_error(f"Invalid filter_json: {e}", 400)

    if carrier:
        match_stage["flightLegState.carrier"] = carrier
    if start_date and end_date:
        match_stage["flightLegState.dateOfOrigin"] = {"$gte": start_date, "$lte": end_date}

    agg_map = {
        "average": {"$avg": f"${field}"},
        "sum": {"$sum": f"${field}"},
        "min": {"$min": f"${field}"},
        "max": {"$max": f"${field}"},
        "count": {"$sum": 1},
    }

    if query_type not in agg_map:
        return response_error(f"Unsupported query_type '{query_type}'. Use one of: average, sum, min, max, count", 400)

    pipeline = [{"$match": match_stage}, {"$group": {"_id": None, "value": agg_map[query_type]}}]

    try:
        logger.info(f"Running aggregation pipeline: {pipeline}")
        docs = await col.aggregate(pipeline).to_list(length=10)
        return response_ok({"pipeline": pipeline, "results": docs})
    except Exception as e:
        logger.exception("Aggregation query failed")
        return response_error(f"Aggregation failed: {str(e)}", 500)



# --- Run MCP Server ---
if __name__ == "__main__":
    logger.info("Starting FlightOps MCP Server on %s:%s (transport=%s)", HOST, PORT, TRANSPORT)
    logger.info("MongoDB URL: %s, Database: %s, Collection: %s", MONGODB_URL, DATABASE_NAME, COLLECTION_NAME)
    mcp.run(transport="streamable-http")
############################################
import os
import json
import logging
import asyncio
from typing import List, Dict, Any

from dotenv import load_dotenv
from openai import AzureOpenAI
from mcp import ClientSession
from mcp.client.streamable_http import streamablehttp_client

from tool_registry import TOOLS

# Load environment variables
load_dotenv()

MCP_SERVER_URL = os.getenv("MCP_SERVER_URL", "http://127.0.0.1:8000").rstrip("/")

# Azure OpenAI configuration
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY")
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4o")
AZURE_API_VERSION = os.getenv("AZURE_API_VERSION", "2024-12-01-preview")

if not AZURE_OPENAI_KEY:
    raise RuntimeError("‚ùå AZURE_OPENAI_KEY not set in environment")

logging.basicConfig(level=os.getenv("LOG_LEVEL", "INFO"))
logger = logging.getLogger("FlightOps.MCPClient")

# Initialize Azure OpenAI client
client_azure = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version=AZURE_API_VERSION,
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)


def _build_tool_prompt() -> str:
    """Convert TOOLS dict into compact text to feed the LLM."""
    lines = []
    for name, meta in TOOLS.items():
        arg_str = ", ".join(meta["args"])
        lines.append(f"- {name}({arg_str}): {meta['desc']}")
    return "\n".join(lines)


SYSTEM_PROMPT_PLAN = f"""
You are an assistant that converts user questions into MCP tool calls.

Available tools:
{_build_tool_prompt()}

### Tool selection logic

1. **Use `run_aggregated_query`** when the user asks for:
   - counts, numbers, totals, sums, averages, minimums, or maximums
   - examples: "how many flights", "number of passengers", "average delay", "max flight time", "total fuel"
   - In such cases:
     - set `"query_type"` to one of ["count", "sum", "average", "min", "max"]
     - set `"field"` to the appropriate MongoDB path (e.g. "flightLegState.pax.passengerCount.count")
     - if the user gives a condition (e.g. "where delay > 30"), include it as `"filter_json"`
     - optionally include `"start_date"` and `"end_date"` for time ranges

     Example:
     {{
       "plan": [
         {{
           "tool": "run_aggregated_query",
           "arguments": {{
             "query_type": "count",
             "field": "flightLegState.pax.passengerCount.count",
             "filter_json": "{{ 'flightLegState.pax.passengerCount.count': {{ '$gt': 100 }} }}"
           }}
         }}
       ]
     }}

2. **Use `raw_mongodb_query`** for:
   - retrieving lists of flights, filtered data, or detailed fields
   - when the question asks to "show", "list", "find", or "get" specific flight data
   - supports `"projection"` to reduce payload (LLM decides what to include)

     Example:
     {{
       "plan": [
         {{
           "tool": "raw_mongodb_query",
           "arguments": {{
             "query_json": "{{ 'flightLegState.startStation': 'DEL', 'flightLegState.endStation': 'BOM' }}",
             "projection": "{{ 'flightLegState.flightNumber': 1, 'flightLegState.startStation': 1, 'flightLegState.endStation': 1, '_id': 0 }}",
             "limit": 10
           }}
         }}
       ]
     }}

3. **Use existing tools** (like get_flight_basic_info, get_delay_summary, etc.) for single-flight queries (where a flight number and date are specified).

---

### Schema summary (for projection guidance)

Flight documents contain(Schema):
    'carrier': 'flightLegState.carrier',
    'date_of_origin': 'flightLegState.dateOfOrigin',
    'flight_number': 'flightLegState.flightNumber',
    'suffix': 'flightLegState.suffix',
    'sequence_number': 'flightLegState.seqNumber',
    'origin': 'flightLegState.startStation',
    'destination': 'flightLegState.endStation',
    'scheduled_departure': 'flightLegState.scheduledStartTime',
    'scheduled_arrival': 'flightLegState.scheduledEndTime',
    'end_terminal': 'flightLegState.endTerminal',
    'operational_status': 'flightLegState.operationalStatus',
    'flight_status': 'flightLegState.flightStatus',
    'start_country': 'flightLegState.startCountry',
    'end_country': 'flightLegState.endCountry',
    'aircraft_registration': 'flightLegState.equipment.aircraftRegistration',
    'aircraft_type': 'flightLegState.equipment.assignedAircraftTypeIATA',
    'start_gate': 'flightLegState.startGate',
    'end_gate': 'flightLegState.endGate',
    'start_terminal': 'flightLegState.startTerminal',
    'delay_total': 'flightLegState.delays.total',
    'flight_type': 'flightLegState.flightType',
    'operations': 'flightLegState.operation',
    'estimated_times': 'flightLegState.operation.estimatedTimes',
    'off_block_time': 'flightLegState.operation.estimatedTimes.offBlock',
    'in_block_time': 'flightLegState.operation.estimatedTimes.inBlock',
    'takeoff_time': 'flightLegState.operation.estimatedTimes.takeoffTime',
    'landing_time': 'flightLegState.operation.estimatedTimes.landingTime',
    'actual_times': 'flightLegState.operation.actualTimes',
    'actual_off_block_time': 'flightLegState.operation.actualTimes.offBlock',
    'actual_in_block_time': 'flightLegState.operation.actualTimes.inBlock',
    'actual_takeoff_time': 'flightLegState.operation.actualTimes.takeoffTime',
    'actual_landing_time': 'flightLegState.operation.actualTimes.landingTime',
    'door_close_time': 'flightLegState.operation.estimatedTimes.doorClose',
    'fuel':'flightLegState.operation.fuel',
    'fuel_off_block':'flightLegState.operation.fuel.offBlock',
    'fuel_takeoff':'flightLegState.operation.fuel.takeoff',
    'fuel_landing':'flightLegState.operation.fuel.landing',
    'fuel_in_block':'flightLegState.operation.fuel.inBlock',
    'autoland':'flightLegState.operation.autoland',
    'flight_plan':'flightLegState.operation.flightPlan',
    'estimated_Elapsed_time':'flightLegState.operation.flightPlan.estimatedElapsedTime',
    'actual_Takeoff_time':'flightLegState.operation.flightPlan.acTakeoffWeight',
    'flight_plan_takeoff_fuel':'flightLegState.operation.flightPlan.takeoffFuel',
    'flight_plan_landing_fuel':'flightLegState.operation.flightPlan.landingFuel',
    'flight_plan_hold_fuel':'flightLegState.operation.flightPlan.holdFuel',
    'flight_plan_hold_time':'flightLegState.operation.flightPlan.holdTime',
    'flight_plan_route_distance':'flightLegState.operation.flightPlan.routeDistance',
    'start_country':'flightLegState.startCountry',
    'end_country':'flightLegState.endCountry',
    'ICAO_start_station':'flightLegState.startStationICAO',
    'ICAO_end_station':'flightLegState.endStationICAO',
    'Flight_otp_achieved':'flightLegState.isOTPAchieved',
    'Flight_otp_considered':'flightLegState.isOTPConsidered',
    'Flight_otp_status':'flightLegState.isOTPFlight',
    'Flight_type':'flightLegState.flightType',
    'scheduled_block_time':'flightLegState.blockTimeSch',
    'acutal_block_time':'flightLegState.blockTimeActual',
    'start_time_offset':'flightLegState.startTimeOffset',
    'end_time_offset':'flightLegState.endTimeOffset',

---

### Projection rules for `raw_mongodb_query`
- Only include fields relevant to the question.
- Always exclude "_id".
- Examples:
  - ‚Äúpassenger‚Äù ‚Üí include flightNumber, pax.passengerCount
  - ‚Äúdelay‚Äù or ‚Äúreason‚Äù ‚Üí include flightNumber, delays.total, delays.delay.reason
  - ‚Äúaircraft‚Äù or ‚Äútail‚Äù ‚Üí include equipment.aircraftRegistration, aircraft.type
  - ‚Äústation‚Äù or ‚Äúsector‚Äù ‚Üí include startStation, endStation, terminals
  - ‚Äúcrew‚Äù ‚Üí include crewConnections.crew.givenName, position
  - ‚Äútiming / departure / arrival / dep / arr‚Äù ‚Üí include scheduledStartTime, scheduledEndTime, operation.actualTimes
  - ‚Äúfuel‚Äù ‚Üí include operation.fuel
  - ‚ÄúOTP‚Äù or ‚Äúon-time‚Äù ‚Üí include isOTPAchieved, flightStatus

---

### General rules
1. Always return valid JSON with a top-level "plan" key.
2. Use the correct tool type based on query intent.
3. Never invent field names ‚Äî use schema fields only.
4. Never return "_id" in projections.
5. For numerical summaries ‚Üí use run_aggregated_query.
6. For filtered listings ‚Üí use raw_mongodb_query.
7. for StartTimeOffset and EndTimeOffset ‚Üí use run_aggregated_query.
6. latest date in the database is 2025-05-30 and consider it today's date
"""


SYSTEM_PROMPT_SUMMARIZE = """
You are an assistant that summarizes tool outputs into a concise, readable answer.
Be factual, short, bullet points format and helpful. 
"""


class FlightOpsMCPClient:
    def __init__(self, base_url: str = None):
        self.base_url = (base_url or MCP_SERVER_URL).rstrip("/")
        self.session: ClientSession = None
        self._client_context = None

    
    async def connect(self):
        try:
            logger.info(f"Connecting to MCP server at {self.base_url}")
            self._client_context = streamablehttp_client(self.base_url)
            read_stream, write_stream, _ = await self._client_context.__aenter__()
            self.session = ClientSession(read_stream, write_stream)
            await self.session.__aenter__()
            await self.session.initialize()
            logger.info("‚úÖ Connected to MCP server successfully")
        except Exception as e:
            logger.error(f"Failed to connect to MCP server: {e}")
            raise

    async def disconnect(self):
        try:
            if self.session:
                await self.session.__aexit__(None, None, None)
            if self._client_context:
                await self._client_context.__aexit__(None, None, None)
            logger.info("Disconnected from MCP server")
        except Exception as e:
            logger.error(f"Error during disconnect: {e}")

    # -------------------- AZURE OPENAI WRAPPER -------------------------
    def _call_azure_openai(self, messages: list, temperature: float = 0.2, max_tokens: int = 2048) -> str:
        try:
            completion = client_azure.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens,
            )
            return completion.choices[0].message.content
        except Exception as e:
            logger.error(f"Azure OpenAI API error: {e}")
            return json.dumps({"error": str(e)})

    # -------------------- MCP TOOL CALLS -------------------------
    async def list_tools(self) -> dict:
        try:
            if not self.session:
                await self.connect()
            tools_list = await self.session.list_tools()
            tools_dict = {tool.name: {"description": tool.description, "inputSchema": tool.inputSchema} for tool in tools_list.tools}
            return {"tools": tools_dict}
        except Exception as e:
            logger.error(f"Error listing tools: {e}")
            return {"error": str(e)}

    async def invoke_tool(self, tool_name: str, args: dict) -> dict:
        try:
            if not self.session:
                await self.connect()
            logger.info(f"Calling tool: {tool_name} with args: {args}")
            result = await self.session.call_tool(tool_name, args)  

            if result.content:
                content_items = []
                for item in result.content:
                    if hasattr(item, 'text'):
                        try:
                            content_items.append(json.loads(item.text))
                        except json.JSONDecodeError:
                            content_items.append(item.text)
                if len(content_items) == 1:
                    return content_items[0]
                return {"results": content_items}

            return {"error": "No content in response"}
        except Exception as e:
            logger.error(f"Error invoking tool {tool_name}: {e}")
            return {"error": str(e)}

    # -------------------- LLM PLANNING & SUMMARIZATION -------------------------
    def plan_tools(self, user_query: str) -> dict:
        """
        Ask the LLM to produce a valid JSON plan for which MCP tools to call.
        Cleans out Markdown-style fences (```json ... ```), which some models add.`````
        """
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_PLAN},
            {"role": "user", "content": user_query},
        ]

        content = self._call_azure_openai(messages, temperature=0.1)
        if not content:
            logger.warning("‚ö†Ô∏è LLM returned empty response during plan generation.")
            return {"plan": []}

        
        cleaned = content.strip()
        if cleaned.startswith("```"):
            
            cleaned = cleaned.strip("`")
            if cleaned.lower().startswith("json"):
                cleaned = cleaned[4:].strip()
            
            cleaned = cleaned.replace("```", "").strip()

        
        if cleaned != content:
            logger.debug(f"üîç Cleaned LLM plan output:\n{cleaned}")

       
        try:
            plan = json.loads(cleaned)
            if isinstance(plan, dict) and "plan" in plan:
                return plan
            else:
                logger.warning("‚ö†Ô∏è LLM output did not contain 'plan' key.")
                return {"plan": []}
        except json.JSONDecodeError:
            logger.warning(f"‚ùå Could not parse LLM plan output after cleaning:\n{cleaned}")
            return {"plan": []}


    def summarize_results(self, user_query: str, plan: list, results: list) -> dict:
        messages = [
            {"role": "system", "content": SYSTEM_PROMPT_SUMMARIZE},
            {"role": "user", "content": f"Question:\n{user_query}"},
            {"role": "assistant", "content": f"Plan:\n{json.dumps(plan, indent=2)}"},
            {"role": "assistant", "content": f"Results:\n{json.dumps(results, indent=2)}"},
        ]
        summary = self._call_azure_openai(messages, temperature=0.3)
        return {"summary": summary}

   
    async def run_query(self, user_query: str) -> dict:
        """
        Full flow:
        1. LLM plans which tools to call (including possible MongoDB query).
        2. Execute tools sequentially via MCP.
        3. Summarize results using LLM.
        """
        try:
            logger.info(f"User query: {user_query}")
            plan_data = self.plan_tools(user_query)
            plan = plan_data.get("plan", [])
            if not plan:
                return {"error": "LLM did not produce a valid tool plan."}

            results = []
            for step in plan:
                tool = step.get("tool")
                args = step.get("arguments", {})

                # Clean up bad args
                args = {k: v for k, v in args.items() if v and str(v).strip().lower() != "unknown"}

                # Safety for MongoDB query
                if tool == "raw_mongodb_query":
                    query_json = args.get("query_json", "")
                    if not query_json:
                        results.append({"raw_mongodb_query": {"error": "Empty query_json"}})
                        continue
                    # Enforce safe default limit
                    args["limit"] = int(args.get("limit", 50))
                    logger.info(f"Executing raw MongoDB query: {query_json}")

                resp = await self.invoke_tool(tool, args)
                results.append({tool: resp})

            summary = self.summarize_results(user_query, plan, results)
            return {"plan": plan, "results": results, "summary": summary}
        except Exception as e:
            logger.error(f"Error in run_query: {e}")
            return {"error": str(e)}
######################################################
import os
import json
import asyncio
import time
import uuid
from typing import AsyncGenerator, List
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
from client import FlightOpsMCPClient

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

# CORS (adjust origins for your Vite origin)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],           # lock down in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

def sse_event(data: dict) -> str:
    """Encode one SSE event (JSON payload)"""
    return f"data: {json.dumps(data, default=str, ensure_ascii=False)}\n\n"

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.on_event("startup")
async def startup_event():
    try:
        await ensure_mcp_connected()
    except Exception:
        # don't crash; /health will reflect status
        pass

@app.get("/")
async def root():
    return {"message": "FlightOps AG-UI Adapter running", "status": "ok"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"status": "healthy", "mcp_connected": True}
    except Exception as e:
        return {"status": "unhealthy", "mcp_connected": False, "error": str(e)}

def chunk_text(txt: str, max_len: int = 200) -> List[str]:
    """
    Split text into small chunks for streaming as typing.
    Prefer sentence boundaries; fallback by length.
    """
    txt = txt or ""
    parts: List[str] = []
    buf = ""

    def flush():
        nonlocal buf
        if buf:
            parts.append(buf)
            buf = ""

    for ch in txt:
        buf += ch
        # flush at sentence end or when too long
        if ch in ".!?\n" and len(buf) >= max_len // 2:
            flush()
        elif len(buf) >= max_len:
            flush()
    flush()
    return parts

@app.post("/agent", response_class=StreamingResponse)
async def run_agent(request: Request):
    """
    AG-UI compatible streaming endpoint (SSE).
    Expected body:
      {
        thread_id?, run_id?,
        messages: [{role, content}, ...],
        tools?: []
      }
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])

    # last user message as query
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "") or ""
        elif isinstance(last, str):
            user_query = last

    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query found")

    async def event_stream() -> AsyncGenerator[str, None]:
        last_heartbeat = time.time()

        # --- RUN STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id})
        
        # THINKING: Initial analysis
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 5,
                "message": "üß† Analyzing your flight query..."
            }
        })

        # ensure MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"})
            return

        loop = asyncio.get_event_loop()

        # --- PLAN (THINKING phase)
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "thinking", 
                "progress_pct": 15,
                "message": "üìã Planning which flight data tools to use..."
            }
        })
        
        try:
            plan_data = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planner error: {e}"})
            return

        plan = plan_data.get("plan", []) if isinstance(plan_data, dict) else []
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan}})

        if not plan:
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT", 
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "assistant",
                    "content": "I couldn't generate a valid plan for your query. Please try rephrasing."
                }
            })
            yield sse_event({"type": "STATE_UPDATE", "state": {"phase": "finished", "progress_pct": 100}})
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})
            return

        # --- PROCESSING: Tool execution
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "processing", 
                "progress_pct": 20,
                "message": f"üõ†Ô∏è Executing {len(plan)} flight data tools..."
            }
        })

        results = []
        num_steps = max(1, len(plan))
        per_step = 60.0 / num_steps  # 20% to 80%
        current_progress = 20.0

        for step_index, step in enumerate(plan):
            if await request.is_disconnected():
                return

            tool_name = step.get("tool")
            args = step.get("arguments", {}) or {}

            # Update processing status for current tool
            yield sse_event({
                "type": "STATE_UPDATE", 
                "state": {
                    "phase": "processing",
                    "progress_pct": round(current_progress),
                    "message": f"üîß Running {tool_name}..."
                }
            })

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"
            
            # Tool call events
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name,
                "parentMessageId": None
            })

            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            })
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id})

            # call tool
            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
            except Exception as exc:
                tool_result = {"error": str(exc)}

            # result
            yield sse_event({
                "type": "TOOL_CALL_RESULT",
                "message": {
                    "id": f"msg-{uuid.uuid4().hex[:8]}",
                    "role": "tool",
                    "content": json.dumps(tool_result, ensure_ascii=False),
                    "tool_call_id": tool_call_id,
                }
            })
            results.append({tool_name: tool_result})

            yield sse_event({
                "type": "STEP_FINISHED",
                "step_index": step_index,
                "tool": tool_name
            })

            # update progress
            current_progress = min(80.0, 20.0 + per_step * (step_index + 1))
            
            # heartbeat every ~15s while long tools run
            if time.time() - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": time.time()})
                last_heartbeat = time.time()

        # --- TYPING: Result generation
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "typing", 
                "progress_pct": 85,
                "message": "‚úçÔ∏è Generating your flight analysis..."
            }
        })

        try:
            summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
        except Exception as e:
            assistant_text = f"‚ùå Failed to summarize results: {e}"

        # Stream summary as chunks (typing effect)
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        
        # Start the message
        yield sse_event({
            "type": "TEXT_MESSAGE_CONTENT",
            "message": {
                "id": msg_id,
                "role": "assistant",
                "content": ""  # Start with empty content
            }
        })

        # Stream chunks with typing effect
        chunks = chunk_text(assistant_text, max_len=150)
        for i, chunk in enumerate(chunks):
            yield sse_event({
                "type": "TEXT_MESSAGE_CONTENT",
                "message": {
                    "id": msg_id,
                    "role": "assistant", 
                    "delta": chunk  # AG-UI delta for streaming
                }
            })
            
            # Update typing progress
            typing_progress = 85 + (i / len(chunks)) * 15
            yield sse_event({
                "type": "STATE_UPDATE",
                "state": {
                    "phase": "typing",
                    "progress_pct": round(typing_progress),
                    "message": "‚úçÔ∏è Generating your flight analysis..."
                }
            })
            
            await asyncio.sleep(0.03)  # Typing speed

        # Final state
        yield sse_event({"type": "STATE_SNAPSHOT", "snapshot": {"plan": plan, "results": results}})
        yield sse_event({
            "type": "STATE_UPDATE", 
            "state": {
                "phase": "finished", 
                "progress_pct": 100,
                "message": "‚úÖ Analysis complete"
            }
        })
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id})

    return StreamingResponse(event_stream(), media_type="text/event-stream")
###################################################
import React, { useState } from "react";
import ChatPage from "./components/ChatPage";

import "./App.css";

export default function App() {
  const [query, setQuery] = useState("");

  return (
    <div className="app-container">
      {/* Sidebar */}
      <div className="sidebar">
        <div className="sidebar-header">
          <div className="logo-container">
            <div className="logo-placeholder">
            <div className="animated-plane">‚úàÔ∏è</div>  
            </div>
          </div>
        </div>
        
        <div className="sidebar-content">
          <div className="sidebar-section">
            <h3>Quick Actions</h3>
            <button className="sidebar-btn">Flight Delays</button>
            <button className="sidebar-btn">Fuel Reports</button>
            <button className="sidebar-btn">Aircraft Info</button>
            <button className="sidebar-btn">Passenger Data</button>
          </div>
          
          <div className="sidebar-section">
            {/* <h3>Recent Queries</h3>
            <div className="recent-query">"Why was 6E215 delayed?"</div>
            <div className="recent-query">"Fuel consumption for AI202"</div>
            <div className="recent-query">"Passenger count for UK945"</div> */}
          </div>

          <div className="indigo-gif-placeholder">
            <div className="gif-container">
              {/* <div className="animated-plane">‚úàÔ∏è</div> */}
              <p>Flight Operations</p>
              <p>Live Monitoring</p>
            </div>
          </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="main-content">
        <div className="header">
          <div className="flex items-center justify-center mt-6 space-x-3">
            <img src="/src/assets/indigo-logo.png" alt="logo" className="h-10" />
            <h1 className="text-2xl font-bold text-indigo-700">
              FlightOps Smart Agent 
            </h1>
          </div>
        </div>
        <ChatPage />
      </div>
    </div>
  );
}
################################################
import React, { useState, useRef, useEffect } from "react";
import MessageBubble from "./MessageBubble";

const AG_AGENT_ENDPOINT = import.meta.env.VITE_AGENT_ENDPOINT || "http://localhost:8001/agent";

export default function ChatPage() {
    const [messages, setMessages] = useState([
        {
            role: "assistant",
            content: "Hello! üëã I'm your FlightOps Agent. Ask me anything about flight operations ‚Äî delays, fuel, passengers, aircraft details, etc.",
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        },
    ]);
    const [input, setInput] = useState("");
    const [loading, setLoading] = useState(false);
    const [agentState, setAgentState] = useState({
        phase: 'idle', // 'thinking' | 'processing' | 'typing' | 'finished' | 'idle'
        progress: 0,
        message: ''
    });
    const messagesEndRef = useRef(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    };

    useEffect(() => {
        scrollToBottom();
    }, [messages]);

    async function sendMessage() {
        if (!input.trim()) return;

        const userMessage = { 
            role: "user", 
            content: input,
            timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
        };
        setMessages((prev) => [...prev, userMessage]);
        setLoading(true);
        setInput("");
        
        // Reset agent state
        setAgentState({
            phase: 'thinking',
            progress: 0,
            message: 'Starting analysis...'
        });

        const body = {
            thread_id: "thread-" + Date.now(),
            run_id: "run-" + Date.now(),
            messages: [userMessage],
        };

        try {
            const resp = await fetch(AG_AGENT_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });

            if (!resp.ok) {
                const errTxt = await resp.text();
                throw new Error(errTxt);
            }

            const reader = resp.body.getReader();
            const decoder = new TextDecoder();
            let buf = "";
            let currentMessageId = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                buf += decoder.decode(value, { stream: true });

                let idx;
                while ((idx = buf.indexOf("\n\n")) !== -1) {
                    const chunk = buf.slice(0, idx).trim();
                    buf = buf.slice(idx + 2);
                    const lines = chunk.split("\n");

                    for (const line of lines) {
                        if (line.startsWith("data: ")) {
                            const payload = line.slice(6).trim();
                            if (!payload) continue;

                            try {
                                const event = JSON.parse(payload);
                                handleEvent(event, currentMessageId);
                            } catch (err) {
                                console.warn("Bad SSE line:", payload);
                            }
                        }
                    }
                }
            }
        } catch (err) {
            setMessages((prev) => [
                ...prev,
                { 
                    role: "assistant", 
                    content: "‚ö†Ô∏è Error: " + err.message,
                    timestamp: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                },
            ]);
            setAgentState({ phase: 'idle', progress: 0, message: '' });
        } finally {
            setLoading(false);
        }
    }

    function handleEvent(event, currentMessageId) {
        const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        switch (event.type) {
            case "STATE_UPDATE":
                setAgentState(event.state);
                break;
                
            case "TEXT_MESSAGE_CONTENT":
                if (event.message) {
                    // Handle streaming text with deltas
                    if (event.message.delta) {
                        setMessages(prev => {
                            const existingIdx = prev.findIndex(m => m.id === event.message.id);
                            if (existingIdx >= 0) {
                                const updated = [...prev];
                                updated[existingIdx].content += event.message.delta;
                                updated[existingIdx].timestamp = timestamp;
                                return updated;
                            } else {
                                return [...prev, {
                                    id: event.message.id,
                                    role: event.message.role,
                                    content: event.message.delta,
                                    timestamp: timestamp
                                }];
                            }
                        });
                    } else if (event.message.content) {
                        // Complete message
                        setMessages(prev => [...prev, {
                            id: event.message.id,
                            role: event.message.role,
                            content: event.message.content,
                            timestamp: timestamp
                        }]);
                    }
                } else if (event.content) {
                    // Legacy format
                    setMessages(prev => [...prev, {
                        role: "assistant",
                        content: event.content,
                        timestamp: timestamp
                    }]);
                }
                break;
                
            case "TOOL_CALL_START":
                setMessages(prev => [...prev, {
                    role: "system",
                    content: `üõ†Ô∏è Starting ${event.toolCallName}...`,
                    timestamp: timestamp
                }]);
                break;
                
            case "TOOL_CALL_RESULT":
                // Optional: show tool results in UI
                // setMessages(prev => [...prev, {
                //     role: "system", 
                //     content: `‚úÖ ${event.toolCallName} completed`,
                //     timestamp: timestamp
                // }]);
                break;
                
            case "RUN_FINISHED":
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            case "RUN_ERROR":
                setMessages(prev => [...prev, {
                    role: "assistant",
                    content: "‚ùå " + event.error,
                    timestamp: timestamp
                }]);
                setAgentState({ phase: 'idle', progress: 0, message: '' });
                break;
                
            default:
                break;
        }
    }

    // Status indicator component
    const StatusIndicator = () => {
        if (agentState.phase === 'idle') return null;
        
        const phaseIcons = {
            thinking: 'üß†',
            processing: 'üõ†Ô∏è', 
            typing: '‚úçÔ∏è',
            finished: '‚úÖ'
        };
        
        return (
            <div className={`status-indicator ${agentState.phase}`}>
                <div className="status-content">
                    <span className="status-icon">{phaseIcons[agentState.phase]}</span>
                    <span className="status-message">{agentState.message}</span>
                    {agentState.progress > 0 && (
                        <div className="progress-bar">
                            <div 
                                className="progress-fill"
                                style={{ width: `${agentState.progress}%` }}
                            ></div>
                        </div>
                    )}
                </div>
            </div>
        );
    };

    return (
        <div className="chat-container">
            <div className="messages-container">
                {messages.map((msg, idx) => (
                    <MessageBubble 
                        key={msg.id || idx} 
                        role={msg.role} 
                        content={msg.content} 
                        timestamp={msg.timestamp}
                    />
                ))}
                
                <StatusIndicator />
                
                {loading && agentState.phase === 'idle' && (
                    <div className="loading-message">
                        <div className="loading-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div className="loading-timestamp">
                            {new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>

            <div className="input-container">
                <input
                    type="text"
                    className="message-input"
                    placeholder="Ask about a flight, e.g. 'Why was 6E215 delayed on June 23, 2024?'"
                    value={input}
                    onChange={(e) => setInput(e.target.value)}
                    onKeyDown={(e) => e.key === "Enter" && sendMessage()}
                    disabled={loading}
                />
                <button
                    onClick={sendMessage}
                    className="send-button"
                    disabled={loading}
                >
                    Send
                </button>
            </div>
        </div>
    );
}
#####################################################
import React from "react";

export default function MessageBubble({ role, content, timestamp }) {
  return (
    <div className={`message ${role}-message`}>
      <div className="message-content">
        <div className="message-text">{content}</div>
        <div className="message-timestamp">{timestamp}</div>
      </div>
    </div>
  );
}
#######################################
/* Reset and base styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  height: 100vh;
  overflow: hidden;
}

.app-container {
  display: flex;
  height: 100vh;
}

/* Sidebar Styles */
.sidebar {
  width: 250px;
  background: linear-gradient(180deg, #1e1b4b 0%, #312e81 100%);
  color: white;
  display: flex;
  flex-direction: column;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.1);
}

.sidebar-header {
  padding: 2rem 1.5rem 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.logo-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  text-align: center;
}

.logo-placeholder {
  width: 60px;
  height: 60px;
  background: linear-gradient(135deg, #818cf8, #4f46e5);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  margin-bottom: 1rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.sidebar-header h1 {
  font-size: 1.1rem;
  font-weight: 600;
  color: #e0e7ff;
}

.sidebar-content {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
}

.sidebar-section {
  margin-bottom: 2rem;
}

.sidebar-section h3 {
  font-size: 0.9rem;
  font-weight: 600;
  color: #a5b4fc;
  margin-bottom: 1rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.sidebar-btn {
  width: 100%;
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: left;
  font-size: 0.9rem;
}

.sidebar-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  transform: translateX(4px);
}

.recent-query {
  padding: 0.75rem 1rem;
  margin-bottom: 0.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 6px;
  font-size: 0.85rem;
  color: #c7d2fe;
  border-left: 3px solid #818cf8;
}

/* Indigo GIF Placeholder */
.indigo-gif-placeholder {
  margin-top: auto;
  padding: 1.5rem;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.gif-container {
  text-align: center;
}

.animated-plane {
  font-size: 3rem;
  margin-bottom: 1rem;
  animation: float 3s ease-in-out infinite;
}

@keyframes float {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

.gif-container p {
  color: #a5b4fc;
  font-size: 0.9rem;
  margin-bottom: 0.25rem;
}

/* Main Content */
.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: #f8fafc;
  overflow: hidden;
}

.header {
  background: white;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  padding: 0.5rem 0;
}

/* Scrollbar Styling */
.sidebar-content::-webkit-scrollbar {
  width: 4px;
}

.sidebar-content::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.1);
}

.sidebar-content::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 2px;
}

.sidebar-content::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.5);
}

/* Responsive Design */
@media (max-width: 768px) {
  .app-container {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    max-height: 200px;
  }
  
  .sidebar-content {
    display: flex;
    overflow-x: auto;
    gap: 1rem;
  }
  
  .sidebar-section {
    flex-shrink: 0;
    margin-bottom: 0;
  }
  
  .indigo-gif-placeholder {
    display: none;
  }
}
/* Chat Container */
.chat-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: white;
  margin: 1rem;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
  overflow: hidden;
}

.messages-container {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
  background: #f8fafc;
}

/* Message Bubbles */
.message {
  margin-bottom: 1.5rem;
  display: flex;
}

.user-message {
  justify-content: flex-end;
}

.user-message .message-content {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
  border-bottom-right-radius: 4px;
}

.assistant-message .message-content {
  background: white;
  color: #374151;
  border: 1px solid #e5e7eb;
  border-bottom-left-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

.message-content {
  max-width: 60%;
  padding: 1rem 1.25rem;
  border-radius: 18px;
  position: relative;
}

.message-text {
  line-height: 1.5;
  margin-bottom: 0.5rem;
}

.message-timestamp {
  font-size: 0.75rem;
  opacity: 0.7;
  margin-top: 0.5rem;
}

.user-message .message-timestamp {
  text-align: right;
  color: rgba(255, 255, 255, 0.8);
}

.assistant-message .message-timestamp {
  text-align: left;
  color: #6b7280;
}

/* Loading Animation */
.loading-message {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  margin-bottom: 1.5rem;
}

.loading-dots {
  display: flex;
  gap: 0.25rem;
  padding: 1rem 1.25rem;
  background: white;
  border-radius: 18px;
  border: 1px solid #e5e7eb;
}

.loading-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #9ca3af;
  animation: bounce 1.4s infinite ease-in-out;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes bounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}

.loading-timestamp {
  font-size: 0.75rem;
  color: #6b7280;
  margin-top: 0.5rem;
  margin-left: 1.25rem;
}

/* Input Container */
.input-container {
  display: flex;
  gap: 0.75rem;
  padding: 1.5rem;
  background: white;
  border-top: 1px solid #e5e7eb;
}

.message-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 1px solid #d1d5db;
  border-radius: 12px;
  font-size: 0.95rem;
  outline: none;
  transition: all 0.2s;
}

.message-input:focus {
  border-color: #4f46e5;
  box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.send-button {
  padding: 0.75rem 1.5rem;
  background: linear-gradient(135deg, #4f46e5, #7c3aed);
  color: white;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.send-button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
}

.send-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

/* Responsive */
@media (max-width: 768px) {
  .message-content {
    max-width: 85%;
  }
  
  .input-container {
    padding: 1rem;
  }
}
.statebar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  border-bottom: 1px solid #e5e7eb;
  background: #fff;
}

.statebar-left {
  display: flex;
  align-items: center;
  gap: 8px;
  min-width: 160px;
}

.state-dot {
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: #10b981; /* green-ish */
  box-shadow: 0 0 0 2px rgba(16,185,129,0.15);
}

.state-text {
  font-size: 0.9rem;
  color: #374151;
  text-transform: capitalize;
}

.statebar-progress {
  flex: 1;
  height: 6px;
  background: #f3f4f6;
  border-radius: 999px;
  overflow: hidden;
}

/* .statebar-progress-fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #4f46e5, #7c3aed);
  border-radius: 999px;
  transition: width 180ms ease;
}
.thinking-bubble .typing-dots {
  display: flex;
  gap: 6px;
  justify-content: flex-start;
  align-items: center;
  padding: 8px 12px;
}

.typing-dots span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #6b7280;
  animation: bounce 1.2s infinite ease-in-out;
}

.typing-dots span:nth-child(1) { animation-delay: 0s; }
.typing-dots span:nth-child(2) { animation-delay: 0.2s; }
.typing-dots span:nth-child(3) { animation-delay: 0.4s; }

@keyframes bounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
} */
.status-indicator {
    padding: 1rem 1.25rem;
    margin: 1rem 0;
    border-radius: 12px;
    background: #f8fafc;
    border: 1px solid #e5e7eb;
    border-left: 4px solid #4f46e5;
}

.status-indicator.thinking {
    border-left-color: #8b5cf6;
    background: #faf5ff;
}

.status-indicator.processing {
    border-left-color: #f59e0b;
    background: #fffbeb;
}

.status-indicator.typing {
    border-left-color: #10b981;
    background: #ecfdf5;
}

.status-content {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.status-icon {
    font-size: 1.25rem;
    margin-right: 0.5rem;
}

.status-message {
    font-weight: 500;
    color: #374151;
    font-size: 0.9rem;
}

.progress-bar {
    width: 100%;
    height: 6px;
    background: #e5e7eb;
    border-radius: 3px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #4f46e5, #7c3aed);
    transition: width 0.3s ease;
    border-radius: 3px;
}

/* Loading dots */
.loading-dots {
    display: flex;
    gap: 0.25rem;
    padding: 1rem 1.25rem;
    background: white;
    border-radius: 18px;
    border: 1px solid #e5e7eb;
}

.loading-dots span {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #9ca3af;
    animation: bounce 1.4s infinite ease-in-out;
}

.loading-dots span:nth-child(1) { animation-delay: -0.32s; }
.loading-dots span:nth-child(2) { animation-delay: -0.16s; }

@keyframes bounce {
    0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
}
