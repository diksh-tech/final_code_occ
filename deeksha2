# ag_ui_adapter.py
import os
import json
import time
import asyncio
import uuid
from typing import AsyncGenerator, Dict, Any, Optional

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware

from client import FlightOpsMCPClient  # your existing client

app = FastAPI(title="FlightOps ‚Äî AG-UI Adapter")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # dev-friendly; tighten for prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

mcp_client = FlightOpsMCPClient()

# --------- helpers ---------
def sse_event(data: dict) -> str:
    # single 'data:' per event (EventSource friendly)
    return "data: " + json.dumps(data, ensure_ascii=False, default=str) + "\n\n"

def chunk_text(text: str, size: int = 500) -> str:
    for i in range(0, len(text), size):
        yield text[i:i+size]

async def ensure_mcp_connected():
    if not mcp_client.session:
        await mcp_client.connect()

@app.get("/")
async def root():
    return {"ok": True, "service": "AG-UI Adapter"}

@app.get("/health")
async def health():
    try:
        await ensure_mcp_connected()
        return {"ok": True, "mcp_connected": True}
    except Exception as e:
        return {"ok": False, "mcp_connected": False, "error": str(e)}

@app.post("/agent")
async def run_agent(request: Request):
    """
    Streams AG-UI-like events:
      RUN_STARTED -> STATE_UPDATE(plan) -> per-step:
        TOOL_CALL_START/ARGS/END, TOOL_CALL_RESULT, STATE_UPDATE(progress)
      TEXT_MESSAGE_CONTENT (delta chunks) -> TEXT_MESSAGE_END
      STATE_UPDATE(final) -> RUN_FINISHED
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="Invalid JSON body")

    thread_id = body.get("thread_id") or f"thread-{uuid.uuid4().hex[:8]}"
    run_id = body.get("run_id") or f"run-{uuid.uuid4().hex[:8]}"
    messages = body.get("messages", [])
    user_query = ""
    if messages:
        last = messages[-1]
        if isinstance(last, dict) and last.get("role") == "user":
            user_query = last.get("content", "")
        elif isinstance(last, str):
            user_query = last
    if not user_query.strip():
        raise HTTPException(status_code=400, detail="No user query")

    async def gen() -> AsyncGenerator[bytes, None]:
        # shared run-state to ‚Äúshow thinking‚Äù
        run_state: Dict[str, Any] = {
            "thread_id": thread_id,
            "run_id": run_id,
            "phase": "starting",
            "plan": [],
            "current_step": None,
            "steps_done": 0,
            "total_steps": 0,
            "progress_pct": 0,
            "tool_results": [],
            "tokens": {"input": 0, "output": 0},  # if you have usage, update these
            "started_at": time.time(),
        }

        last_heartbeat = time.time()

        # RUN_STARTED
        yield sse_event({"type": "RUN_STARTED", "thread_id": thread_id, "run_id": run_id}).encode()

        # connect MCP
        try:
            await ensure_mcp_connected()
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"MCP connect failed: {e}"}).encode()
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id}).encode()
            return

        # Planning
        run_state["phase"] = "planning"
        yield sse_event({"type": "STATE_UPDATE", "state": run_state}).encode()
        loop = asyncio.get_event_loop()
        try:
            plan_obj = await loop.run_in_executor(None, mcp_client.plan_tools, user_query)
        except Exception as e:
            yield sse_event({"type": "RUN_ERROR", "error": f"Planning failed: {e}"}).encode()
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id}).encode()
            return

        plan = plan_obj.get("plan", [])
        run_state["plan"] = plan
        run_state["total_steps"] = len(plan)
        yield sse_event({"type": "STATE_UPDATE", "state": run_state}).encode()

        if not plan:
            yield sse_event({"type": "TEXT_MESSAGE_CONTENT", "message": {
                "id": f"msg-{uuid.uuid4().hex[:8]}",
                "role": "assistant",
                "content": "No valid plan produced."
            }}).encode()
            yield sse_event({"type": "RUN_FINISHED", "run_id": run_id}).encode()
            return

        # Execute plan steps
        run_state["phase"] = "executing"
        results = []

        for idx, step in enumerate(plan, start=1):
            # graceful disconnect
            if await request.is_disconnected():
                yield sse_event({"type": "RUN_ERROR", "error": "Client disconnected"}).encode()
                return

            tool_name = step.get("tool")
            args = (step.get("arguments") or {})
            args = {k: v for k, v in args.items() if v not in (None, "", "unknown")}

            tool_call_id = f"toolcall-{uuid.uuid4().hex[:8]}"

            # TOOL_CALL_START
            yield sse_event({
                "type": "TOOL_CALL_START",
                "toolCallId": tool_call_id,
                "toolCallName": tool_name
            }).encode()

            # TOOL_CALL_ARGS
            yield sse_event({
                "type": "TOOL_CALL_ARGS",
                "toolCallId": tool_call_id,
                "delta": json.dumps(args, ensure_ascii=False)
            }).encode()

            # TOOL_CALL_END (args done)
            yield sse_event({"type": "TOOL_CALL_END", "toolCallId": tool_call_id}).encode()

            # invoke tool
            try:
                tool_result = await mcp_client.invoke_tool(tool_name, args)
            except Exception as e:
                tool_result = {"error": str(e)}

            # TOOL_CALL_RESULT
            tool_msg = {
                "id": f"msg-{uuid.uuid4().hex[:8]}",
                "role": "tool",
                "content": json.dumps(tool_result, ensure_ascii=False),
                "tool_call_id": tool_call_id,
            }
            yield sse_event({"type": "TOOL_CALL_RESULT", "message": tool_msg}).encode()

            results.append({tool_name: tool_result})

            # update state/progress
            run_state["steps_done"] = idx
            run_state["current_step"] = tool_name
            if run_state["total_steps"]:
                run_state["progress_pct"] = int((idx / run_state["total_steps"]) * 100)

            run_state["tool_results"] = results
            yield sse_event({"type": "STATE_UPDATE", "state": run_state}).encode()
            yield sse_event({"type": "PROGRESS", "value": run_state["progress_pct"]}).encode()

            # heartbeat every 15s
            now = time.time()
            if now - last_heartbeat > 15:
                yield sse_event({"type": "HEARTBEAT", "ts": now}).encode()
                last_heartbeat = now

        # Summarization
        yield sse_event({"type": "TEXT_MESSAGE_CONTENT", "message": {
            "id": f"msg-{uuid.uuid4().hex[:8]}",
            "role": "assistant",
            "content": "Summarizing results..."
        }}).encode()

        try:
            summary_obj = await loop.run_in_executor(None, mcp_client.summarize_results, user_query, plan, results)
            assistant_text: str = summary_obj.get("summary", "") if isinstance(summary_obj, dict) else str(summary_obj)
        except Exception as e:
            assistant_text = f"Failed to summarize results: {e}"

        # Stream summary in chunks (delta style)
        msg_id = f"msg-{uuid.uuid4().hex[:8]}"
        accumulated = 0
        for part in chunk_text(assistant_text, size=600):
            accumulated += len(part)
            yield sse_event({"type": "TEXT_MESSAGE_CONTENT", "message": {
                "id": msg_id,
                "role": "assistant",
                "delta": part
            }}).encode()

            # Optional live tokens/length (fake here; wire real usage if you have it)
            run_state["tokens"]["output"] += len(part)
            yield sse_event({"type": "STATE_UPDATE", "state": run_state}).encode()

        # close the streamed assistant message
        yield sse_event({"type": "TEXT_MESSAGE_END", "messageId": msg_id}).encode()

        # Final snapshot + finish
        run_state["phase"] = "finished"
        yield sse_event({"type": "STATE_UPDATE", "state": run_state}).encode()
        yield sse_event({"type": "RUN_FINISHED", "run_id": run_id}).encode()

    # Important headers for SSE
    headers = {
        "Cache-Control": "no-cache, no-transform",
        "Connection": "keep-alive",
        "X-Accel-Buffering": "no",  # nginx buffering off (if behind nginx)
    }
    return StreamingResponse(gen(), media_type="text/event-stream", headers=headers)
####################################################
      /** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,jsx,ts,tsx}"],
  theme: { extend: {} },
  plugins: [],
};
######################
  export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
#############################
  <!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0" />
    <title>FlightOps Assistant</title>
  </head>
  <body class="bg-gray-50">
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
#########################################3
@tailwind base;
@tailwind components;
@tailwind utilities;

/* optional scrollbar nice */
::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 8px; }
###########################################
 import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App.jsx";

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
#######################################3
  import React from "react";
import Chat from "./components/Chat.jsx";

export default function App() {
  const endpoint = import.meta.env.VITE_AGENT_ENDPOINT || "http://localhost:8001/agent";
  return (
    <div className="min-h-screen flex flex-col">
      <header className="border-b bg-white">
        <div className="max-w-5xl mx-auto px-4 py-3 flex items-center gap-3">
          <span className="text-2xl">‚úàÔ∏è</span>
          <h1 className="text-xl font-semibold">FlightOps Assistant</h1>
          <span className="ml-auto text-xs text-gray-500">SSE Streaming + Tailwind</span>
        </div>
      </header>

      <main className="flex-1">
        <div className="max-w-5xl mx-auto px-4 py-6">
          <Chat endpoint={endpoint} />
        </div>
      </main>
    </div>
  );
}
##############################
  import React from "react";

export default function MessageBubble({ role, content }) {
  const isUser = role === "user";
  return (
    <div className={`flex ${isUser ? "justify-end" : "justify-start"} my-2`}>
      <div
        className={`max-w-[70%] rounded-2xl px-4 py-2 whitespace-pre-wrap shadow
          ${isUser ? "bg-blue-600 text-white rounded-br-sm" : "bg-white text-gray-900 rounded-bl-sm"}`}>
        <div className="text-sm leading-relaxed">
          {isUser ? "üßë " : "ü§ñ "}
          {content || ""}
        </div>
      </div>
    </div>
  );
}
########################################
import React from "react";

export default function TypingIndicator({ phase = "thinking", progress = 0 }) {
  return (
    <div className="flex items-center gap-3 text-gray-600 text-sm">
      <span className="animate-pulse">ü§ñ</span>
      <span className="capitalize">{phase}</span>
      <div className="w-40 h-2 bg-gray-200 rounded overflow-hidden">
        <div
          className="h-full bg-blue-500 transition-all"
          style={{ width: `${progress}%` }}
        />
      </div>
      <span className="w-10 text-right">{Math.floor(progress)}%</span>
    </div>
  );
}
################################################
 import React, { useState, useRef, useEffect } from "react";
import MessageBubble from "./MessageBubble.jsx";
import TypingIndicator from "./TypingIndicator.jsx";

export default function Chat({ endpoint }) {
  const [messages, setMessages] = useState([
    { id: "m0", role: "assistant", content: "üëã Hi! Ask me about flights. Example:\n‚Ä¢ Why was flight 6E215 delayed on 2024-06-23?\n‚Ä¢ Show fuel vs plan for 6E215 on 2024-06-23." }
  ]);
  const [query, setQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const [phase, setPhase] = useState("idle");
  const [progress, setProgress] = useState(0);
  const [plan, setPlan] = useState(null);
  const [toolEvents, setToolEvents] = useState([]); // array of {index, tool, args, result}
  const streamedMsgIdRef = useRef(null);
  const listRef = useRef(null);

  useEffect(() => {
    listRef.current?.scrollTo({ top: listRef.current.scrollHeight, behavior: "smooth" });
  }, [messages, loading, toolEvents]);

  const pushAssistantContainerIfNeeded = () => {
    if (!streamedMsgIdRef.current) {
      const id = "asst-" + Date.now();
      streamedMsgIdRef.current = id;
      setMessages(prev => [...prev, { id, role: "assistant", content: "" }]);
    }
  };

  const appendToAssistant = (delta) => {
    if (!streamedMsgIdRef.current) return;
    setMessages(prev =>
      prev.map(m =>
        m.id === streamedMsgIdRef.current
          ? { ...m, content: (m.content || "") + delta }
          : m
      )
    );
  };

  async function sendMessage() {
    if (!query.trim() || loading) return;
    const userMsg = { id: "u-" + Date.now(), role: "user", content: query };
    setMessages(prev => [...prev, userMsg]);

    // reset stream state
    setQuery("");
    setLoading(true);
    setPhase("planning");
    setProgress(5);
    setPlan(null);
    setToolEvents([]);
    streamedMsgIdRef.current = null;

    // payload mirrors AG-UI adapter expectations
    const body = {
      thread_id: "thread-" + Date.now(),
      run_id: "run-" + Date.now(),
      messages: [...messages, userMsg].map(({ role, content }) => ({ role, content })),
      tools: []
    };

    let resp;
    try {
      resp = await fetch(endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });
    } catch (e) {
      setMessages(prev => [...prev, { id: "err1", role: "assistant", content: "‚ùå Cannot reach server." }]);
      setLoading(false);
      return;
    }

    if (!resp.ok || !resp.body) {
      const text = await resp.text().catch(() => "");
      setMessages(prev => [...prev, { id: "err2", role: "assistant", content: `‚ùå Server error: ${text}` }]);
      setLoading(false);
      return;
    }

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buf = "";

    // streaming loop
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += decoder.decode(value, { stream: true });

      let idx;
      while ((idx = buf.indexOf("\n\n")) !== -1) {
        const chunk = buf.slice(0, idx).trim();
        buf = buf.slice(idx + 2);

        for (const line of chunk.split("\n")) {
          if (!line.startsWith("data:")) continue;
          const payload = line.slice(5).trim();
          if (!payload) continue;

          let evt;
          try { evt = JSON.parse(payload); } catch { continue; }

          // Handle server events
          switch (evt.type) {
            case "RUN_STARTED":
              setPhase("planning");
              setProgress(10);
              break;

            case "STATE_SNAPSHOT":
              if (evt.snapshot?.plan) setPlan(evt.snapshot.plan);
              break;

            case "STATE_UPDATE":
              if (evt.state?.phase) setPhase(evt.state.phase);
              if (evt.state?.progress_pct != null) setProgress(evt.state.progress_pct);
              break;

            case "TEXT_MESSAGE_CONTENT":
              pushAssistantContainerIfNeeded();
              // server may send a 'message' object or simple 'content'
              if (evt.message?.delta) {
                appendToAssistant(evt.message.delta);
              } else if (evt.message?.content) {
                appendToAssistant(evt.message.content);
              } else if (evt.content) {
                // plain content
                appendToAssistant(evt.content + "\n");
              }
              break;

            case "TOOL_CALL_START":
              setPhase("running tools");
              setProgress(p => Math.min(90, p + 5));
              setToolEvents(prev => [...prev, { index: evt.step_index ?? (prev.length + 1), tool: evt.toolCallName, args: null, result: null }]);
              break;

            case "TOOL_CALL_ARGS":
              setToolEvents(prev => {
                const last = [...prev];
                if (last.length > 0) {
                  const i = last.length - 1;
                  last[i] = { ...last[i], args: evt.delta ? safeJson(evt.delta) : evt };
                }
                return last;
              });
              break;

            case "TOOL_CALL_RESULT":
              setToolEvents(prev => {
                const last = [...prev];
                if (last.length > 0) {
                  const i = last.length - 1;
                  last[i] = { ...last[i], result: parseMaybeJson(evt.message?.content) };
                }
                return last;
              });
              setProgress(p => Math.min(95, p + 3));
              break;

            case "STEP_FINISHED":
              setProgress(p => Math.min(96, p + 2));
              break;

            case "RUN_FINISHED":
              setPhase("finished");
              setProgress(100);
              setLoading(false);
              break;

            case "RUN_ERROR":
              pushAssistantContainerIfNeeded();
              appendToAssistant("\n‚ö†Ô∏è " + (evt.error || "Unknown error"));
              setLoading(false);
              setPhase("error");
              break;

            default:
              // ignore or log
              break;
          }
        }
      }
    }
  }

  const safeJson = (s) => {
    try { return JSON.parse(s); } catch { return s; }
  };
  const parseMaybeJson = (s) => {
    if (typeof s !== "string") return s;
    try { return JSON.parse(s); } catch { return s; }
  };

  return (
    <div className="bg-white rounded-2xl shadow border flex flex-col h-[80vh]">
      {/* header */}
      <div className="p-4 border-b flex items-center gap-3">
        <div className="text-sm text-gray-500">
          Phase: <span className="font-medium text-gray-700">{phase}</span>
        </div>
        <div className="ml-4 w-48 h-2 bg-gray-200 rounded overflow-hidden">
          <div className="h-full bg-blue-500 transition-all" style={{ width: `${progress}%` }} />
        </div>
        {loading && <span className="ml-3 text-xs text-gray-500">streaming‚Ä¶</span>}
        <div className="ml-auto text-xs text-gray-400">SSE</div>
      </div>

      {/* conversation list */}
      <div ref={listRef} className="flex-1 overflow-y-auto p-4">
        {messages.map(m => (
          <MessageBubble key={m.id} role={m.role} content={m.content} />
        ))}

        {/* plan & tools (optional visibility) */}
        {plan && (
          <div className="mt-4">
            <div className="text-xs uppercase tracking-wide text-gray-500 mb-1">Planned steps</div>
            <div className="bg-gray-50 border rounded p-3 text-sm font-mono overflow-x-auto">
              <pre className="whitespace-pre-wrap">{JSON.stringify(plan, null, 2)}</pre>
            </div>
          </div>
        )}

        {toolEvents.length > 0 && (
          <div className="mt-4">
            <div className="text-xs uppercase tracking-wide text-gray-500 mb-1">Tool runs</div>
            <div className="space-y-2">
              {toolEvents.map((t, i) => (
                <div key={i} className="bg-slate-50 border rounded p-3">
                  <div className="text-sm font-semibold text-slate-700">{t.tool}</div>
                  {t.args && (
                    <div className="mt-1 text-xs text-slate-600">
                      <div className="font-semibold">args</div>
                      <pre className="whitespace-pre-wrap">{JSON.stringify(t.args, null, 2)}</pre>
                    </div>
                  )}
                  {t.result && (
                    <div className="mt-1 text-xs text-slate-600">
                      <div className="font-semibold">result</div>
                      <pre className="whitespace-pre-wrap">{JSON.stringify(t.result, null, 2)}</pre>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}

        {loading && (
          <div className="mt-6">
            <TypingIndicator phase={phase} progress={progress} />
          </div>
        )}
      </div>

      {/* input */}
      <div className="border-t p-3 bg-gray-50">
        <div className="flex gap-2">
          <textarea
            rows={2}
            className="flex-1 resize-none rounded-xl border px-3 py-2 outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Ask about a flight‚Ä¶"
            value={query}
            onChange={(e) => setQuery(e.target.value)}
          />
          <button
            onClick={sendMessage}
            disabled={loading}
            className={`rounded-xl px-5 py-2 font-medium text-white
              ${loading ? "bg-blue-300 cursor-not-allowed" : "bg-blue-600 hover:bg-blue-700"}`}>
            {loading ? "Thinking‚Ä¶" : "Send"}
          </button>
        </div>
        <div className="mt-2 text-[11px] text-gray-500">
          Backend endpoint: <code>{endpoint}</code>
        </div>
      </div>
    </div>
  );
}
   
